<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/24/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-08-24T07:38:40.798Z" itemprop="datePublished">2022-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/24/hello-world/" data-id="cl77b2vjt0000ukfy68beepsn" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDN_Final" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/25/SDN_Final/" class="article-date">
  <time class="dt-published" datetime="2022-07-24T18:46:15.330Z" itemprop="datePublished">2022-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>##读书报告</p>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><p>论文于1988年发表，美国国防先进技术研究计划署已于15年前开发出了互联网协议族，TCP&#x2F;IP，其中包括IP和TCP两个代表性协议。在之后的15年间，协议族得到了广泛的应用，军事上成为了当时美国国防部内网的标准，商业上在经济领域也广泛应用；此外，受其影响还设计出了许多的协议，如X.25、ARPAnet和ISO无连接网络协议等。</p>
<h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2 问题"></a>2 问题</h3><p>互联网协议本是为了能够提供无连接或报文模式服务而设计的，后来经过了良好的发展，不断丰富互联网协议，发展了分层架构、报文、无连接等特征。然而一些发展出的特征与互联网协议最初的动机并无关联。此论文作者试图发掘互联网协议族的设计动机，以及影响互联网协议族发展的因素，讨论了设计动机和协议特征之间的关系。作者试图通过研究互联网的设计哲学，给互联网架构的发展提供有意义的借鉴。</p>
<h3 id="3-设计理念总结"><a href="#3-设计理念总结" class="headerlink" title="3 设计理念总结"></a>3 设计理念总结</h3><p>3.1 互联网架构的主要设计动机与协议特征</p>
<p>作者首先从基础层次的目标进行分析，分析出互联网基础设计动机是使得多种网络环境之间能够自由沟通；若采用电路交换，应用也需要通过分组交换实现，且分组交换已有成熟的技术即ARPAnet，因此采用分组交换技术，但分组交换技术仅限于ARPAnet；若想实现实现不同的网络互联，需要在网络层通过网管交换包。因此初级的设计思想是：基于分组交换技术，在各种各样的网络之间通过网管处理分组，实现网络的互联，网关中执行存储转发分组交换算法。</p>
<p>3.2 互联网架构的次要设计动机与协议特征</p>
<p>作者从第二层次的目标进行分析，为实现有效的互联网，分析出了一系列更详细的目标，包含网络的可靠性、网络提供的服务、异构网络融合、分布式资源管理、合适的成本、主机方便地接入、网络资源的可控。从这一系列目标探讨与互联网特征之间的关系。</p>
<p>3.2.1 为提高网络的可靠性，需要通过传输层协议保证传输的连续，根据传输层协议自动重传。重传需要通信的状态信息，状态信息若存储至网络中，无法保证状态信息复制的成功，因此将状态信息保存至网络终端中，降低了实现难度同时提升了容错性。主机连接到整个网络并且使用整个网络上的服务，交换节点也不需要处理分组，只需要按照地址进行转发即可。</p>
<p>3.2.2 为提供多种服务，需设计不同的传输协议。传统的服务类型是针对可靠数据传输的，通过TCP协议提供传输服务；而对于语音实时传输等业务，对实时性要求高、对可靠性要求低，因此需要为不同类型业务提供不同的服务。为此需要分割传输层与网络层，将文件的传输都隔离到网络层之下，网络层只负责分组的转发、传送。通过上层机制来保证传输可靠性，如TCP提供可靠数据传输服务、UDP提供尽力而为的传输服务。</p>
<p>3.2.3 为融合异构网络，互联网架构合理地集成利用了大量的网络技术，能够成功地调配着各种各样的网络，包括远程网、局域网、卫星网等。为了向各种网络提供互联网的功能，各个网络可以传输包或报文。需要合理的数据包大小、可靠的传输机制、合理的寻址方式。若想实现额外的功能，需要将网络融入互联网中，由网络本身提供服务，网络本身实现服务即可，且容易实现。</p>
<p>3.2.4 为实现分布式网络，互联网中有很多网关，由不同的机构管理，并执行路由算法，为了正确的路由，不管两个忘关之间是否相互信任，都要交换路由表。各个忘关的路由根据各网络自动&#x2F;手动设置。</p>
<p>3.2.5 为了降低网络成本，与包有关，互联网中的数据报头较长，如果包很小，那代价就会变得很大；若包很大，则头部开销就微不足道。网络成本也与网络重发和可靠性有关，丢失的包的重发也导致了网络的低效，需要在发送端重发丢失的包，若重发率较高，达到10%，则就需要提高网络可靠性。</p>
<p>3.2.6 为了主机方便的接入，需要在主机中提供所需服务类型的所有机制，起初是苦难的，后来随着协议经验的增加，可以可以在各种机器上实现，包括个人计算机和计算资源非常有限的其他机器。</p>
<p>3.2.7 为实现网络资源可控，运行商需要考虑到数据包、网络资源的可控性，从而进行计费。</p>
<p>3.3 互联网架构设计与实际执行</p>
<p>架构的设计与实际应用之间的关系很是复杂。架构是为了适应各种情况而设计的，且任何工具都不可能形式化描述实际因素，因此若只是考虑逻辑正确性而忽略对实际性能的影响因素是大错特错的，然而将实际性能的影响考虑进架构内部也会带来很大的困难。因此需要将性能约束添加到协议中，以实现对不同类型服务的提供。</p>
<p>3.4 数据传输单元-数据报的设计</p>
<p>在互联网架构中在底层网络是用数据报来整合数据传输的。省去了普通数据包中的保存复制状态信息的开销，可以修复网络错误而不必要求状态信息；数据报屏蔽了各种不同服务本身数据传输方式的差异性；与支持确定服务的虚电路相比，数据报可以提供更基本的服务，而这些服务又可以进一步支持其他更高级各种各样的服务；数据报代表着最基本的网络服务，这种服务支持各种各样的网络实体成功互联。</p>
<p>3.5 传输控制协议TCP的设计</p>
<p>在早期ARPAnet提供的流控制包括比特和包两种方式，TCP的设计者为了简化，只对字节传输进行校准，且流控制和应答也是机遇字节数；选择字节流还是为了方便的把包切分成更小的包以适应网上的包尺寸限制；选择字节流的也是为了方便在数据重发时，发送端将小包聚合成一个大包。TCP中使用EOL将字节流切分成记录，并将数据以记录的形式放到独立的包中，这与在重新传输时组合数据包的思想不兼容，已在协议中被Push标志或PSH取代。</p>
<p>###4 个人理解</p>
<p>互联网的一些设计动机随着发展愈发得以验证，如文中所说，起初将网络层与传输层分离是为了向传输层提供数据传输服务；随着网络协议发展，得益于IP细腰的设计理念，发展出了丰富的底层网络技术和上层应用。得益于互联网的设计动机，互联网机构得以良好的发展。在融合异构网络这一动机上，随着移动通信、互联网技术、卫星通信网络的高速发展，涌现出了大量不同的通信网络，为用户提供了多种多样的通信方式与网络接入手段，通过互联互通这些网络，充分利用不同网络间的互补特性，能够大大提高网络整体效用与用户体验。</p>
<p>然而互联网当初的设计动机也可能满足不了如今的需求，如文中所示，互联网架构的主要设计动机是基于分组交换技术，在各种各样的网络之间通过网管处理分组，实现网络的互联，网关中执行存储转发分组交换算法。起初的互联网架构是针对提供消费型互联网的大连接问题，网络的应用开放，然而网络架构不开放，面对新的大带宽、低时延、确定性等需求，无法平滑过渡，难以满足工业界的需求。而通过白盒网络，实现网络的开放、可定制、可编程、可重构；分离控制与承载，实现开放化网络。在国内，紫金山实验室自主研制了全球首个大网级网络操作系统CNOS，满足差异化网络应用的可定制、可重构需求，可实现分钟级网络开通和业务开通，解决了传统互联网架构、网络设备不开放、不可编程的问题。</p>
<p>一些传统的设计理念也需要随着网络发展而改变，如文中所示互联网以网络资源可控为设计理念之一，然而随着网络发展，网络更需要为用户在网络上提供不同的服务，如AR&#x2F;VR、自动驾驶、无人机等业务。即网络需要以应用服务为中心，并向智能化、网算存一体等方向发展。在网络上引入智能化，并在网络上提供计算、存储等功能，提高网络资源利用率，根据用户需求提供服务。</p>
<p>通过分析设计动机和协议特征之间的关系，我们可知互联网协议起初的设计动机仅仅是为了能够提供无连接或报文模式服务而设计的，而人们对互联网协议所期望实现的目标，一定程度上影响着协议的特征，使得互联网协议发展的愈发完善。有时候一些原始想法是很简单的，实际操作中却会变得很复杂；同时，有些在设计者设计之初时考虑的，并不能很好的满足实际用户的需求，如互联网架构的账户、资源管理以及分布式管理操作；有些技术能满足部分设计动机，但却满足不了其他的效果，如报文技术很难处理好资源管理和易读易控的问题。通过分析互联网协议与最初动机的偏差，并分析人们对于互联网协议实现的目标，有助于之后互联网协议的不断完善、进一步发展。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/25/SDN_Final/" data-id="cl77bm6pr00082kfy33g7cvc9" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDN" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/24/SDN/" class="article-date">
  <time class="dt-published" datetime="2022-07-23T17:51:09.823Z" itemprop="datePublished">2022-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SDN读书报告"><a href="#SDN读书报告" class="headerlink" title="SDN读书报告"></a>SDN读书报告</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>​	<strong>1、请每位同学从给定的10篇网络领域高水平英文论文中任选一篇，结合自己的思考独立完成一篇读书报告。</strong></p>
<p>​	<strong>2、请同学们7月31日24：00之前提交实验报告到，报告名称统一为“学号-姓名-SDN读书报告”。最后评分将根据同学们报告内容的完成程度进行评分。</strong></p>
<p>​	<strong>3、读书报告的内容必须包括：①背景、问题、解决方案的总结，②谈谈你对方案的理解。</strong></p>
<p>​	<strong>4、有想法和能力的同学可以继续选择以下内容进行扩展：③能不能找到改进或提高的地方，④能否提出具体的方法，⑤进行系统设计并实现，⑥如何构造仿真环境并验证自己的想法。</strong></p>
<h2 id="二、论文-The-Design-Philosophy-of-the-DARPA-Internet-Protocols"><a href="#二、论文-The-Design-Philosophy-of-the-DARPA-Internet-Protocols" class="headerlink" title="二、论文-The Design Philosophy of the DARPA Internet Protocols"></a>二、论文-The Design Philosophy of the DARPA Internet Protocols</h2><h3 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0.摘要"></a>0.摘要</h3><p>互联网协议套件TCP&#x2F;IP是十五年前首次提出的。它是由国防高级研究计划局（DARPA）开发的，已广泛应用于军事和商业系统。虽然有一些论文和规范描述了协议的工作方式，但有时很难从中推断出协议的存在原因。例如，互联网协议基于无连接或数据报服务模式。这样做的动机被严重误解。本文试图捕捉形成互联网协议的一些早期原因。</p>
<h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><p>在过去15年中，美国国防部高级研究计划局一直在开发一套用于分组交换网络的协议。这些协议包括互联网协议（IP）和传输控制协议（TCP），现在是美国国防部互联网工作标准，并在商业网络环境中广泛使用。在这项工作中开发的思想也影响了其他协议套件，最重要的是ISO协议的无连接配置2,3,4</p>
<p>虽然国防部协议的具体信息普遍可用5,6,7，但有时很难确定导致设计的动机和推理。</p>
<p>事实上，从第一个提案到当前标准，设计理念已经有了很大的发展。例如，数据报或无连接服务的概念在第一篇论文中没有得到特别强调，但已成为IP和TCP层架构的定义特征。这似乎是设计的基础，但也不是原始方案的一部分。互联网设计中的这些变化是通过在标准制定之前重复执行和测试的模式产生的。</p>
<p>互联网架构仍在不断发展。有时，新的扩展挑战了设计原则之一，但无论如何，对设计历史的理解为当前的设计扩展提供了必要的背景。ISO协议的无连接配置也受到互联网套件历史的影响，因此了解互联网设计理念可能有助于使用ISO的人员。</p>
<p>本文对互联网架构的原始目标进行了分类，并讨论了这些目标与协议的重要特征之间的关系。</p>
<p>###2.基本目标</p>
<p>DARPA互联网架构的最高目标是开发一种有效的技术，用于现有互联网络的多路复用。有必要进行详细阐述，以明确该目标的含义。</p>
<p>互联网的组成部分是网络，它们相互连接以提供更大的服务。最初的目标是将原始ARPANET8与ARPA分组无线网络9,10连接在一起，以便分组无线网络上的用户能够访问ARPANet上的大型服务机器。当时，人们认为会有其他种类的网络相互连接，尽管局域网尚未出现。</p>
<p>连接现有网络的另一种选择是设计一个统一的系统，该系统包含各种不同的传输媒体，即多媒体网络。虽然这可能允许更高程度的集成，从而获得更好的性能，但人们认为，如果互联网要在实际意义上有用，就有必要合并当时存在的网络架构。此外，网络代表了控制的行政边界，本项目的目标是解决将多个单独管理的实体集成到公共事业中的问题。</p>
<p>多路复用选择的技术是分组交换。本可以考虑电路交换等替代方案，但支持的应用程序（如远程登录）自然由分组交换范式服务，本项目中要集成在一起的网络是分组交换网络。因此，分组交换被认为是互联网体系结构的基本组成部分。</p>
<p>这一基本目标的最后一个方面是假设将这些网络相互连接的特定技术。正如前一个DARPA项目ARPANET中所演示的那样，由于存储和转发分组交换技术已被充分理解，因此顶层假设是网络将由一层称为网关的互联网分组交换机互连。</p>
<p>从这些假设中得出了互联网的基本结构：一种分组交换通信设施，其中许多可区分的网络使用称为网关的分组通信处理器连接在一起，这些处理器实现了前向和前向分组转发算法。</p>
<h3 id="3-二级目标"><a href="#3-二级目标" class="headerlink" title="3.二级目标"></a>3.二级目标</h3><p>上一节中所述的顶级目标包含“有效”一词，但没有提供有效互连必须实现的任何定义。以下列表总结了为互联网架构制定的一组更详细的目标。</p>
<p>1.尽管网络或网关丢失，但互联网通信必须继续。</p>
<p>2.互联网必须支持多种类型的通信服务。</p>
<p>3.互联网架构必须适应各种网络。</p>
<p>4.互联网架构必须允许对其资源进行分布式管理。</p>
<p>5.互联网架构必须具有成本效益。</p>
<p>6.互联网架构必须允许主机连接，且工作量较低。</p>
<p>7.互联网架构中使用的资源必须是负责的。</p>
<p>这组目标似乎只不过是所有理想网络功能的检查表。重要的是要理解这些目标是按重要性排序的，如果顺序发生变化，则会产生完全不同的网络架构。例如，由于该网络设计用于在军事环境中运行，这意味着可能存在敌对环境，因此生存能力被视为首要目标，问责制被视为最后目标。在战争期间，人们更关心的是召集任何可用的资源，并以作战方式快速部署它们，而不是详细核算所使用的资源。虽然互联网的架构师们注意到了问责制，但在设计的早期阶段，这个问题很少受到关注，现在才被考虑。主要用于商业部署的架构显然会将这些目标放在列表的另一端。</p>
<p>类似地，体系结构具有成本效益的目标显然在列表中，但低于某些其他目标，例如分布式管理或支持多种网络。其他协议套件，包括一些更流行的商业架构，已优化到特定类型的网络，例如由中速电话线构建的长途存储转发网络，并在这方面提供了一个非常经济高效的解决方案，以交换处理其他类型网络的一些问题，例如局域网。</p>
<p>读者应仔细考虑上述目标列表，并认识到这不是一个“母亲”列表，而是一组优先事项，这些优先事项强烈影响了互联网架构中的设计决策。以下各节讨论了该列表与互联网特征之间的关系。</p>
<h3 id="4-面对失败的生存能力"><a href="#4-面对失败的生存能力" class="headerlink" title="4.面对失败的生存能力"></a>4.面对失败的生存能力</h3><p>名单上最重要的目标是，即使网络和网关出现故障，互联网仍应继续提供通信服务。特别是，这一目标被解释为意味着，如果两个实体在互联网上通信，并且一些故障导致互联网暂时中断并重新配置服务，那么通信实体应该能够继续，而不必重新建立或重置其通信的高级状态。</p>
<p>更具体地说，在传输层的服务接口处，该架构不提供与传输服务的客户端通信的设施，即发送方和接收方之间的同步可能已经丢失。该架构中的一个假设是，除非没有任何物理路径可以实现任何类型的通信，否则同步永远不会丢失。换句话说，在传输的顶部，只有一个失败，那就是全部分割。该架构旨在完全掩盖任何瞬时故障。</p>
<p>为了实现这一目标，必须保护描述正在进行的会话的状态信息。状态信息的具体示例是传输的数据包数、已确认的数据包数或未完成的流控制权限数。如果架构的较低层丢失了这些信息，它们将无法判断数据是否丢失，应用层将不得不应对同步性的丢失。该架构坚持认为不会发生这种中断，这意味着必须保护状态信息不丢失。</p>
<p>在某些网络架构中，该状态存储在网络的中间分组交换节点中。在这种情况下，为了防止信息丢失，必须对其进行复制。由于复制的分布式性质，确保鲁棒复制的算法本身很难构建，并且具有分布式状态信息的网络很少提供任何类型的故障保护。该架构选择的另一种选择是，将这些信息收集到网络的端点，即利用网络服务的实体。我将这种可靠性方法称为“命运共享”。命运共享模型表明，如果实体本身同时丢失，则丢失与实体相关的状态信息是可以接受的。具体来说，有关传输级同步的信息存储在连接到网络并使用其通信服务的主机中。</p>
<p>命运共享过度应用有两个重要的优点。首先，命运共享可以防止任何数量的中间故障，而复制只能防止一定数量的中间故障（少于复制副本的数量）。其次，命运共享比复制更容易工程化。</p>
<p>生存能力的命运分享方法有两个后果。首先，中间分组交换节点或网关不得具有任何关于正在进行的连接的基本状态信息。相反，它们是无状态分组交换机，这是一种有时被称为“数据报”网络的网络设计。其次，与网络确保数据可靠传输的体系结构相比，更信任主机。如果确保数据排序和确认的主机驻留算法失败，则该机器上的应用程序将无法运行。</p>
<p>尽管生存能力是列表中的第一个目标，但它仍然仅次于现有网络互连的顶级目标。单一多媒体网络设计可能会产生一种更具生存能力的技术。例如，互联网对网络报告失败的能力的假设非常弱。因此，互联网被迫使用互联网级别的机制来检测网络故障，这可能导致更慢、更不具体的错误检测。</p>
<h3 id="5-服务类型"><a href="#5-服务类型" class="headerlink" title="5.服务类型"></a>5.服务类型</h3><p>互联网架构的第二个目标是，它应该在运输服务级别支持各种类型的服务。不同类型的服务因对速度、延迟和可靠性等方面的不同要求而不同。传统的服务类型是双向可靠交付数据。该服务有时被称为“虚拟电路”服务，适用于远程登录或文件传输等应用程序。这是互联网体系结构中使用传输控制协议（TCP）11提供的第一项服务。人们很早就认识到，即使是这项服务也有多种变体，因为远程登录需要的服务交付延迟较低，但对带宽的要求较低，而文件传输不太关心延迟，但非常关注高吞吐量。TCP试图提供这两种类型的服务。</p>
<p>TCP的最初概念是，它可以支持任何需要的服务类型。然而，随着所需的全部服务变得清晰，似乎很难在一个协议中建立对所有服务的支持。</p>
<p>TCP范围之外的第一个服务示例是支持XNET12，即跨互联网调试器。TCP似乎不适合XNET的传输，原因有几个。首先，调试器协议不应该是可靠的。这个结论可能看起来很奇怪，但在压力或失败的情况下（这可能正是需要调试器的时候），要求可靠的通信可能会阻止任何通信。更好的做法是构建一个能够处理通过的任何内容的服务，而不是坚持按顺序交付发送的每个字节。其次，如果TCP足够通用，可以处理范围广泛的客户端，那么它可能有点复杂。同样，在调试环境中期望对这种复杂性的支持似乎是错误的，因为调试环境甚至可能缺少操作系统中期望的基本服务（例如，对计时器的支持）。因此，XNET被设计为直接在Internet提供的数据报服务的顶部运行。</p>
<p>另一项不适合TCP的服务是数字化语音的实时传输，这是支持指挥和控制应用程序的远程会议方面所需要的。在实时数字语音中，首要的要求不是可靠的服务，而是最小化和平滑数据包传递延迟的服务。应用层对模拟语音进行数字化，将生成的比特打包，并定期通过网络发送出去。它们必须定期到达接收器，以便转换回模拟信号。如果数据包未按预期到达，则无法实时收集信号。关于延迟变化控制的一个令人惊讶的观察结果是，网络中最严重的延迟源是提供可靠传输的机制。典型的可靠传输协议通过请求重新传输和延迟任何后续数据包的交付来响应丢失的数据包，直到丢失的数据包被重新传输。然后，它按顺序传递该数据包和所有剩余的数据包。发生这种情况时的延迟可能是网络往返传递时间的许多倍，并且可能会完全中断语音重组算法。相反，它很容易处理偶然丢失的数据包。缺失的语音可以简单地用一段短时间的沉默来代替，在大多数情况下，沉默不会影响语音的可懂度。如果是这样，就会出现高水平的纠错，听者可以要求说话者重复受损的短语。</p>
<p>因此，在互联网体系结构开发的相当早的时候，就决定需要多个传输服务，并且该体系结构必须准备好同时容忍希望限制可靠性、延迟或带宽的传输。</p>
<p>这一目标导致TCP和IP（最初在体系结构中是单一协议）被分为两层。TCP提供了一种特定类型的服务，即可靠的序列数据流，而IP则试图提供一种基本的构建块，从中可以构建各种类型的服务。这个构建块就是数据报，它也被用来支持生存能力。由于与数据报交付相关的可靠性没有得到保证，但“尽了最大努力”，因此可以从数据报中构建可靠的服务（通过更高级别的确认和重新传输），或为底层网络底层的原始延迟特性提供可靠性的服务。创建用户数据报协议（UDP）13是为了向互联网的基本数据报服务提供应用程序级接口。</p>
<p>该架构不希望假设底层网络本身支持多种类型的服务，因为这违反了使用现有网络的目标。相反，我们希望可以使用主机和网关内的算法从基本数据报构建块构建多种类型的服务。例如，（尽管在大多数当前实现中没有这样做），可以获取与受控延迟但不可靠服务相关联的数据报，并将其置于传输队列的前端，除非其生存期已过，在这种情况下，它们将被丢弃；而与可靠流相关联的数据包将被放置在队列的后面，但无论它们在网络中的时间有多长，都不会被丢弃。</p>
<p>事实证明，如果没有底层网络的明确支持，提供多种类型的服务比最初希望的要困难得多。最严重的问题是，考虑到一种特定类型的服务而设计的网络不够灵活，无法支持其他服务。最常见的情况是，网络将在其应提供可靠服务的假设下设计，并将注入延迟作为产生可靠服务的一部分，无论是否需要这种可靠性。例如，X.25定义的接口行为意味着可靠的交付，并且无法关闭此功能。因此，尽管Internet在X.25网络上成功运行，但它无法在该上下文中交付所需的类型服务的可变性。具有内在数据报服务的其他网络在其允许的服务类型方面更加灵活，但这些网络不太常见，尤其是在长途环境中。</p>
<h3 id="6-各种网络"><a href="#6-各种网络" class="headerlink" title="6.各种网络"></a>6.各种网络</h3><p>互联网架构的成功非常重要，因为它能够融合和利用各种网络技术，包括军事和商业设施。互联网架构在实现这一目标方面非常成功；它在各种网络上运行，包括长途网（ARPANET本身和各种X.25网络）、局域网（以太网、环网等），广播卫星网（DARPA大西洋卫星网14,15以每秒64千位的速度运行，DARPA实验宽带卫星网16以每秒3兆位的速度在美国运行），分组无线电网络（DARPA分组无线电网络，以及实验性英国分组无线电网络和业余无线电运营商开发的网络）、各种串行链路，从每秒1200位异步连接到T1链路，以及各种其他特殊设施，包括计算机间总线和其他网络套件（如IBM的HASP）的更高层提供的传输服务。</p>
<p>互联网架构通过对网络将提供的功能进行最少的假设来实现这种灵活性。基本假设是网络可以传输数据包或数据图。数据包必须具有合理的大小，可能至少100字节，并且应该以合理但不完美的可靠性交付。如果网络不仅仅是点对点链接，那么它必须具有某种合适的寻址形式。</p>
<p>有许多服务明确不来自网络。这些包括可靠或顺序交付、网络级广播或多播、传输数据包的优先级排序、对多种类型服务的支持，以及故障、速度或延迟的内部知识。如果需要这些服务，那么为了适应互联网中的网络，网络必须直接支持这些服务，或者网络接口软件提供增强功能，以在网络端点模拟这些服务。人们认为这是一种不可取的方法，因为这些服务必须为每个网络和每个网络的每个主机接口重新设计和实施。通过在传输中对这些服务进行工程设计，例如通过TCP进行可靠交付，工程设计必须只进行一次，并且每个主机只能执行一次。之后，新网络的接口软件的实现通常非常简单。</p>
<h3 id="7-其他目标"><a href="#7-其他目标" class="headerlink" title="7.其他目标"></a>7.其他目标</h3><p>到目前为止，讨论的三个目标是对架构设计影响最深远的目标。剩下的目标，因为它们的重要性较低，可能没有得到有效的实现，或者没有完全设计好。允许分布式管理互联网的目标已经在某些方面得到了实现。例如，并非互联网上的所有网关都由同一机构实施和管理。在部署的互联网中有几个不同的管理中心，每个中心运行网关的一个子集，并且有一个两层路由算法，允许来自不同管理部门的网关交换路由表，即使它们彼此不完全信任，以及在单个管理中的网关之间使用的各种私有路由算法。类似地，管理网关的各种组织不一定与管理网关所连接的网络的组织相同。</p>
<p>另一方面，当今互联网最重要的一些问题与缺乏足够的分布式管理工具有关，尤其是在路由领域。在当前运行的大型互联网中，路由决策需要受到资源使用策略的训练。今天，这只能以非常有限的方式完成，这需要手动设置表格。这很容易出错，同时功能不够强大。未来几年，互联网架构中最重要的变化可能是开发新一代工具，用于在多个管理机构的背景下管理资源。</p>
<p>很明显，在某些情况下，互联网体系结构不会像定制的体系结构那样，以经济高效的方式自动利用昂贵的通信资源。互联网数据包的报头相当长（典型的报头是40字节），如果发送短数据包，这种开销是明显的。当然，最糟糕的情况是单字符远程登录数据包，其中包含40个字节的头和一个字节的数据。实际上，任何协议套件都很难声称这些交互更改是以合理的效率执行的。另一个极端是，用于文件传输的大数据包（可能包含1000字节的数据）的头开销仅为4%。</p>
<p>效率低下的另一个可能原因是丢失数据包的电子传输。由于Internet并不坚持在网络级别恢复丢失的数据包，因此可能需要将丢失的数据包从Internet的一端重新传输到另一端。这意味着，重新传输的数据包可能会再次跨越多个服务网络，而在网络级别的恢复不会产生这种重复流量。这是上面讨论的从端点提供服务的决策所产生的权衡示例。网络接口代码更简单，但总体效率可能更低。然而，如果重传率足够低（例如，1%），那么增量成本是可以容忍的。对于架构中包含的网络，粗略的经验法则是，百分之一的数据包丢失是相当合理的，但十分之一的数据包丢失表明，如果需要哪种类型的服务，则应向网络添加可靠性增强。</p>
<p>将主机连接到Internet的成本可能比其他架构中的成本稍高，因为提供所需服务类型的所有机制，例如确认和重新传输策略必须在主机而不是网络中实施。最初，对于不熟悉协议实现的程序员来说，这样做的努力似乎有些令人畏惧。实现者尝试了将传输协议移动到前端处理器等事情，他们的想法是，协议只执行一次，而不是对每种类型的主机执行一次。然而，这需要发明一种主机到前端协议，有些人认为该协议的实现几乎与原始传输协议一样复杂。随着协议经验的增加，与在主机内实现协议套件相关的焦虑似乎在减少，现在可以在各种机器上实现，包括个人计算机和计算资源非常有限的其他机器。</p>
<p>使用驻留在主机上的机制所产生的一个相关问题是，该机制的不良实现可能会损害网络和主机。这个问题是可以容忍的，因为最初的实验涉及数量有限的可以控制的主机实现。然而，随着互联网使用的增长，这个问题偶尔会以严重的方式出现。在这方面，鲁棒性目标导致了命运共享方法，导致了宿主驻留算法，如果宿主行为不当，则会导致鲁棒性损失</p>
<p>最后一个目标是问责制。事实上，Cerf和Kahn在第一篇论文中讨论了计费作为协议和网关的重要功能。然而，目前，互联网架构包含的用于计算数据包流的工具很少。这个问题现在才被研究，因为架构的范围正在扩大，以包括非军事消费者，他们严重关注了解和监控互联网内资源的使用情况。</p>
<h3 id="8-架构和实施"><a href="#8-架构和实施" class="headerlink" title="8.架构和实施"></a>8.架构和实施</h3><p>前面的讨论清楚地表明，互联网架构的目标之一是在所提供的服务中提供广泛的灵活性。可以使用不同的传输协议来提供不同类型的服务，并且可以合并不同的网络。换句话说，架构非常努力地避免训练互联网可以提供的服务范围。这反过来意味着，要理解互联网的特定实现可以提供的服务，人们必须关注的不是架构，而是特定主机和网关内软件的实际工程，以及已合并的特定网络。我将使用术语“实现”来描述在互联网架构的背景下连接在一起的一组特定网络、网关和主机。在他们提供的服务中，实现可能会有数量级的差异。实现是基于每秒1200位的电话线，以及速度大于每秒1兆位的网络。显然，人们对这些认识的透彻期望存在数量级的差异。类似地，一些互联网实现具有以毫秒为单位测量的延迟，而其他实现具有以秒为单位测量的延迟。某些应用程序（如实时语音）在这两种实现中的工作方式根本不同。一些互联网的设计使得网关和路径具有很大的冗余。这些互联网是可以生存的，因为存在可以在故障后重新配置的资源。为了降低成本，其他互联网实现通过实现具有单点连接，因此故障可能会将互联网分成两半。</p>
<p>互联网架构允许通过设计实现这种多样性。然而，它给特定实现的设计者留下了大量的工程要做。这种架构开发的主要任务之一是理解如何为实现的设计者提供指导，指导将实现的工程与将产生的服务类型联系起来。例如，设计师必须回答以下问题。如果整体服务要提供一定的吞吐量，那么底层网络中必须有什么样的带宽？考虑到该实现中可能出现的故障的某个模型，应该在实现中设计什么样的冗余？</p>
<p>大多数已知的网络设计辅助工具似乎对回答这类问题没有帮助。例如，协议验证器帮助确认协议符合规范。然而，这些工具几乎从不处理性能问题，这对于服务类型的概念至关重要。相反，它们处理的是关于规范的协议逻辑正确性的更受限制的想法。虽然用于验证逻辑正确性的工具在规范和实现阶段都很有用，但它们无助于解决经常出现的与性能相关的严重问题。一个典型的实现经验是，即使在证明了逻辑正确性之后，也会发现可能导致性能降低一个数量级的设计错误。对这个问题的探索得出了这样的结论，即困难通常不是出现在协议本身，而是出现在协议运行的操作系统中。在这种情况下，很难在架构规范的上下文中解决这个问题。然而，我们仍然强烈感到需要给实施者提供指导。我们今天继续与这个问题作斗争。</p>
<p>另一类设计辅助是模拟器，它采用特定的实现并探索在各种负载下可以提供的服务。还没有人试图构建一个模拟器，该模拟器考虑了网关实现、主机实现以及在可能的互联网实现中看到的网络性能的广泛可变性。因此，大多数互联网实现的分析都是在信封的背面进行的。这是对互联网架构目标结构的一种评论，即如果由知识渊博的人进行后台分析，通常就足够了。特定互联网实现的设计者通常不太关心获得最后5%的在线利用率，而更关心的是在目前手头有资源的情况下是否能够实现所需类型的服务。</p>
<p>架构和性能之间的关系是一个极具挑战性的关系。互联网架构的设计者强烈认为，只关注逻辑正确性而忽略性能问题是一个严重的错误。然而，他们在将架构内性能约束的任何方面形式化方面都遇到了很大的困难。出现这些困难的原因是架构的目标不是约束性能，而是允许可变性，其次（可能更根本的原因是），因为似乎没有可用的形式化工具来描述性能。</p>
<p>这个问题尤其严重，因为互联网项目的目标是生成规范文档，这些文档将成为军事标准。这是一个众所周知的政府合同问题，不能期望承包商满足任何不属于采购标准的标准。因此，如果互联网关注性能，则必须将性能要求纳入采购规范。对于约束性能的规范来说，例如指定实现必须能够每秒传递1000个数据包，这是微不足道的。然而，这种约束不能成为架构的一部分，因此，执行采购的个人必须认识到，必须将这些性能约束添加到规范中，并适当地加以规定，以实现提供所需服务类型的区域化。我们不知道如何在架构中为执行此任务的人员提供指导。</p>
<h3 id="9-数据报"><a href="#9-数据报" class="headerlink" title="9.数据报"></a>9.数据报</h3><p>互联网的基本架构特征是使用数据报作为跨底层网络传输的实体。正如本文所指出的，数据报在体系结构中很重要有几个原因。首先，它们消除了中间交换节点内对连接状态的需要，这意味着互联网可以在发生故障后重新构建，而不必担心状态。其次，数据报提供了一个基本的构建块，可以实现各种类型的服务。与虚拟电路（通常意味着固定类型的服务）相反，数据报提供了更基本的服务，端点可以适当地将其组合以构建所需的服务类型。第三，数据报代表了最小网络服务假设，该假设允许将各种各样的网络合并到各种互联网实现中。使用数据报的决定是一个非常成功的决定，这使互联网能够非常成功地实现其最重要的目标。</p>
<p>有一个错误的假设通常与数据报相关，即数据报的动机是支持更高级别的服务，该服务本质上与数据报等效。换句话说，有时有人建议提供数据报，因为应用程序需要的传输服务是数据报服务。事实上，这种情况很少发生。虽然Internet中的一些应用程序（例如数据服务器或名称服务器的简单查询）使用基于不可靠数据报的访问方法，但Internet中的大多数服务希望使用比简单数据报更复杂的传输模型。一些服务希望提高可靠性，一些希望平滑和缓冲延迟，但几乎所有服务都有一些比数据报更复杂的期望。重要的是要理解数据报在这方面的作用是作为构建块，而不是作为服务本身。</p>
<h3 id="10-TCP"><a href="#10-TCP" class="headerlink" title="10.TCP"></a>10.TCP</h3><p>在TCP的开发中有几个有趣且有争议的设计决策，TCP本身在成为一个合理稳定的标准之前经历了几个主要版本。其中一些设计决策，如窗口管理和端口地址结构的性质，在作为TCP协议手册的一部分发布的一系列实现说明中进行了讨论。17,18但有时缺乏做出决定的动机。在本节中，我试图捕捉TCP部分中的一些早期推理。本节必要时不完整；全面回顾TCP本身的历史需要另一篇这么长的论文</p>
<p>原始的ARPANET主机对主机协议提供了基于字节和数据包的流量控制。这似乎过于复杂，TCP的设计者认为只有一种形式的监管就足够了。选择是规范字节的传递，而不是数据包。因此，TCPI中的流控制和确认基于字节数而不是数据包数。事实上，在TCP中，数据的打包并不重要</p>
<p>这一决定是出于几个考虑，其中一些考虑变得无关紧要，而另一些则比预期的更重要。确认字节的一个原因是允许将控制信息插入字节的序列空间，以便能够确认控制和数据。放弃了序列空间的使用，转而采用特殊技术来处理每个控制消息。虽然最初的想法具有吸引力的一般性，但它在实践中造成了复杂性。</p>
<p>字节流的第二个原因是允许在必要时将TCP数据包分解为较小的数据包，以适应具有较小数据包大小的网络。但是，当IP从TCP中分离出来时，这个功能被转移到IP层，IP被迫采用另一种分割方法。</p>
<p>确认字节而不是数据包的第三个原因是，如果需要重新传输数据，则允许在发送主机中将多个小数据包合并成一个较大的数据包。目前尚不清楚这一优势是否重要；结果很关键。诸如UNIX之类的系统具有基于单字符交互的内部通信模型，它们通常发送多个数据包，其中包含一个字节的数据。（从网络的角度来看，人们可能会争辩说，这种行为很愚蠢，但它是真实的，并且是交互式远程登录的必要条件。）人们经常观察到，这样的主机可以生成一堆包含一个字节数据的数据包，这些数据包的到达速度要比慢速主机处理它们的速度快得多。结果是数据包丢失和重新传输</p>
<p>如果重新传输的是原始数据包，那么在每次重新传输时都会重复相同的问题，对性能的影响是无法忍受的，以至于无法阻止操作。但是，由于字节被收集到一个数据包中进行重新传输，因此重新传输以更有效的方式发生，从而允许实际操作。</p>
<p>另一方面，字节的确认可以被视为首先造成了这个问题。如果流量控制的基础是数据包而不是字节，那么这种洪水可能永远不会发生。然而，如果发送小数据包，则在数据包级别的控制会对吞吐量造成严重限制。如果接收主机指定要接收的数据包数量，而不知道每个数据包中的字节数，则实际接收的数据量可能会变化1000倍，这取决于发送主机在每个数据包中放置的是1个字节还是1000个字节。</p>
<p>回顾过去，正确的设计决策可能是，如果TCP要提供对各种服务的有效支持，就必须像在原始ARPANET协议中那样对数据包和字节进行管理。</p>
<p>另一个与字节流相关的设计决策是字母结束标志，即EOL。这一点现在已从协议中消失，由推标志或PSH取代。EOL的最初想法是将字节流分解为记录。它是通过将来自不同记录的数据放入不同的数据包来实现的，这与在重新传输时组合数据包的思想不兼容。因此，EOL的语义被更改为一种较弱的形式，这意味着流中到目前为止的数据是一个或多个完整的应用程序级元素，这应该引起TCP或网络中任何内部缓冲的溢出。通过说“一个或多个”而不是“恰好一个”，可以将几个组合在一起，并保持在重新组装中压缩数据的目标。但较弱的语义意味着各种应用程序必须发明一种特别的机制，用于在数据流顶部对记录进行定界。</p>
<p>在EOL语义的演变过程中，有一种鲜为人知的中间形式，引起了很大的争论。根据主机的缓冲策略，TCP的字节流模型在一种不太可能的情况下会造成很大的问题。考虑一个主机，其中输入数据放在一系列固定大小的缓冲区中。缓冲区已满或接收到EOL时返回给用户。现在考虑一个无序数据包的到达情况，该数据包远远无序，超出了当前缓冲区。现在进一步考虑一下，在接收到这个无序数据包后，具有EOL的数据包会导致当前缓冲区仅部分地返回给用户。由于返回给用户的缓冲区中的空字节，这种特定的操作顺序会导致下一个缓冲区中的无序数据位于错误的位置。处理这一问题在主机中产生了一些似乎不必要的图书保管问题。</p>
<p>为了解决这个问题，有人建议EOL应该“用尽”所有序列空间，直到下一个值，即缓冲区大小为零。换句话说，有人提出EOL应该是一种将字节流映射到主机缓冲区管理的工具。</p>
<p>这个想法当时没有得到很好的接受，因为它看起来太特别了，只有一位主机似乎有这个问题。*回顾过去，将序列空间与主机的缓冲区管理算法相关联的一些方法纳入TCP可能是正确的想法。当时，设计师们只是缺乏足够的洞察力来了解如何以足够普遍的方式做到这一点。</p>
<h3 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h3><p>就其优先事项而言，互联网架构非常成功。这些协议广泛用于商业和军事环境，并产生了许多类似的体系结构。同时，它的成功表明，在某些情况下，设计师的优先级与实际用户的需求不匹配。需要更多地关注计费、资源管理和分管区域的运营。</p>
<p>有时候一些原始想法是很简单的，实际操作中却会变得很复杂。</p>
<p>虽然数据报在解决互联网最重要的目标方面发挥了很好的作用，但当我们试图解决优先级列表中较低的一些目标时，它的作用并不那么好。例如，事实证明，在数据报的背景下，资源管理和问责制的目标很难实现。正如前一节所讨论的，大多数数据报是从源到目标的某些数据包序列的一部分，而不是应用程序级别的孤立单元。然而，网关无法直接看到该序列的存在，因为它被迫孤立地处理每个数据包。因此，必须对每个数据包分别进行资源管理决策或记帐。将数据报模型强加给互联网层剥夺了该层在实现这些目标时可以使用的重要信息源。</p>
<p>这表明，对于下一代架构，可能有比数据报更好的构建块。该构建块的一般特征是，它将识别从源到目标的数据包序列，而不假设该服务具有任何特定类型的服务。我用“流”这个词来描述这个构建块。网关有必要具有流状态，以便记住通过它们的流的性质，但状态信息在维护与流相关的所需服务类型方面并不关键。相反，该类型的服务将由端点强制执行，端点将定期发送消息，以确保正确的服务类型与流相关联。这样，与流相关的状态信息可能会在崩溃中丢失，而不会永久中断所使用的服务功能。我将这一概念称为“软状态”，它很可能允许我们实现生存能力和灵活性的主要目标，同时更好地处理资源管理和问责制问题。探索替代构建块是DARPA互联网项目中当前的研究方向之一。</p>
<h3 id="12-承认——历史视角"><a href="#12-承认——历史视角" class="headerlink" title="12.承认——历史视角"></a>12.承认——历史视角</h3><p>不可能承认互联网项目的所有贡献者；在15年的发展过程中，有数百人：设计师、实施者、作家和评论家。事实上，一个重要的主题是管理这个项目的过程，它本身可能值得一篇论文。参与者来自大学、研究实验室和公司，他们（在某种程度上）团结一致以实现这一共同目标。</p>
<p>TCP的最初愿景来自Robert Kahn与 Vinton Cerf，早在1973年，他就非常清楚地看到，一个具有适当功能的协议如何成为将各种新兴网络技术结合在一起的粘合剂。从他们在DARPA的职位开始，他们在项目早期就指导该项目，使TCP和IP成为国防部的标准。</p>
<p>本文作者于70年代中期加入该项目，并于1981年接管了CP&#x2F;IP的建筑责任。他要感谢所有与他一起工作的人，特别是那些花时间重建本文中一些丢失的历史的人。</p>
<p>##三、读书报告</p>
<h3 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h3><p>论文于1988年发表，美国国防先进技术研究计划署已于15年前开发出了互联网协议族，TCP&#x2F;IP，其中包括IP和TCP两个代表性协议。在之后的15年间，协议族得到了广泛的应用，军事上成为了当时美国国防部内网的标准，商业上在经济领域也广泛应用；此外，受其影响还设计出了许多的协议，如X.25、ARPAnet和ISO无连接网络协议等。</p>
<h3 id="3-2-问题"><a href="#3-2-问题" class="headerlink" title="3.2 问题"></a>3.2 问题</h3><p>互联网协议本是为了能够提供无连接或报文模式服务而设计的，后来经过了良好的发展，不断丰富互联网协议，发展了分层架构、报文、无连接等特征。然而一些发展出的特征与互联网协议最初的动机并无关联。缺少一篇论文研究互联网协议组的设计哲学，对以往的互联网设计哲学的良好理解可以给因特网体系架构的发展提供有意义的借鉴。此论文作者试图发掘互联网协议组的设计动机，以及影响互联网协议族的因素，讨论了设计动机和协议特征之间的关系。</p>
<h3 id="3-3-解决方案"><a href="#3-3-解决方案" class="headerlink" title="3.3 解决方案"></a>3.3 解决方案</h3><p>作者首先从基础层次的目标进行分析，分析处互联网基础设计动机是使得多种网络环境之间能够自由沟通；若采用电路交换，应用也需要通过分组交换实现，且分组交换已有成熟的技术即ARPAnet，因此采用分组交换技术，但分组交换技术仅限于ARPAnet；若想实现实现不同的网络互联，需要在网络层通过网管交换包。因此初级的设计思想是：基于分组交换技术，在各种各样的网络之间通过网管处理分组，实现网络的互联，网关中执行存储转发分组交换算法。</p>
<p>其次，作者从第二层次的目标进行分析，为实现有效的互联网，分析出了一系列更详细的目标，包含网络的可靠性、网络提供的服务、异构网络融合、分布式资源管理、合适的成本、主机方便地接入、网络资源的可控。</p>
<p>之后，作者从这一系列目标探讨与互联网特征之间的关系。</p>
<p>作者探讨网络可靠性，探究了与传输层可靠数据传输服务的额外开销特点的关系，探究了与网络层路由器、链路层交换机只根据地址进行转发的特点有关，也探讨了网络层为传输层服务的特点。为提高网络的可靠性，需要通过传输层协议保证传输的连续，根据传输层协议自动重传。重传需要通信的状态信息，状态信息若存储至网络中，无法保证状态信息复制的成功，因此将状态信息保存至网络终端中，降低了实现难度同时提升了容错性。主机连接到整个网络并且使用整个网络上的服务，交换节点也不需要处理分组，只需要按照地址进行转发即可。</p>
<p>作者探讨网络提供的服务，探讨了网络层与传输层的隔离、网络层为传输层服务的特点，探讨了传输层为不同的业务提供不同数据传输机制的特点。传统的服务类型是针对可靠数据传输的，通过TCP协议提供传输服务；而对于语音实时传输等业务，对实时性要求高，对可靠性要求低，因此需要为不同类型业务提供不同的服务。为此需要分割传输层与网络层，将文件的传输都隔离到网络层之下，网络层只负责分组的转发、传送。通过上层机制来保证传输可靠性，如TCP提供可靠数据传输服务、UDP提供尽力而为的传输服务。</p>
<p>作者探讨异构网络的互联网实现，探究了相关协议规范的必要性，探究了网络层只负责传输、额外功能服务由网络本身来提供。互联网体系合理地集成利用了大量的网络技术，能够成功地调配着各种各样的网络，包括远程网、局域网、卫星网等。为了向各种网络提供互联网的功能，包括网络可以传输包或报文。需要合理的数据包大小、可靠的传输机制、合理的寻址方式。若想实现额外的功能，需要将网络融入互联网中，由网络本身提供服务，网络本身实现服务即可，容易实现；否则网络层要为每一个网络甚至每一个主机重新设计实现这些服务，实现难度高。</p>
<p>作者探讨网络分布式的实现，探究了网关实现网络互联、不同高层协议网络互联的特点。互联网中有很多网关，由不同的机构管理，并执行路由算法，为了正确的路由，不管两个忘关之间是否相互信任，都要交换路由表。各个忘关的路由根据各网络自动&#x2F;手动设置。</p>
<p>作者研究了网络成本，探究了网络成本与包的关系，探究了网络重发和可靠性的关系。因为互联网中的数据报头较长，如果包很小，那代价就会变得很大；若包很大，则头部开销就微不足道。事实上，对于任何一种协议来说，提出基于提高效率的传输方案都是非常难的。丢失的包的重发也导致了网络的低效，需要在发送端重发丢失的包，如果重发率足够低，那么这么消耗还是可以容忍的；若重发率较高，到了10%的话，则就需要提高网络可靠性。随着协议的发展、计算机性能的提升，主机可以很好的执行重发。</p>
<p>作者探究了网络资源可控，探究了当时互联网不关注网络资源可控性。尽管Cerf和Kahn执笔的第一篇论文把资源可控性作为了一个非常重要的特征，但由于互联网之前用于军事等领域，步关注数据包的解读，而运行商需要考虑到数据包、网络资源的可控性，从而进行计费。</p>
<p>之后，作者探讨了设计理论的体系与实际执行的关系。体系与实际应用之间的关系很是复杂。体系是为了适应各种情况而设计的，并且根本就不会有一种可以形式化描述实际因素的工具，导致若只是考虑逻辑正确性而忽略实际影响因素是大错特错的，然而将实际影响考虑进体系内部也会带来很大的困难。</p>
<p>作者分析了数据报的设计动机，探讨了在底层网络中传输数据的数据报特点，并说明数据报的建立为什么十分成功。在互联网架构中在底层网络是用数据报来整合数据传输的。省去了普通数据包中的保存复制状态信息的开销，可以修复网络错误而不必要求状态信息；数据报屏蔽了各种不同服务本身数据传输方式的差异性；与支持确定服务的虚电路相比，数据报可以提供更基本的服务，而这些服务又可以进一步支持其他更高级各种各样的服务；数据报代表着最基本的网络服务，这种服务支持各种各样的网络实体成功互联。</p>
<p>最后作者分析了TCP协议的设计动机，探讨了选择字节流的原因。早期ARPAnet提供的流控制包括比特和包两种方式，TCP的设计者为了简化，只使用一种规范，于是就对字节传输进行校准，而不是包；流控制和应答也是机遇字节数而非包数。选择字节流还是为了方便的把包切分成更小的包以适应网上的包尺寸限制，但之后改为通过IP使用不同的方式去切分包。选择字节流的也是为了方便在数据重发时，发送端将小包聚合成一个大包。像UNIX系统中，内部数据传输时经常会只传输一个字节的数据。</p>
<p>###3.5 个人对方案理解</p>
<p>通过分析设计动机和协议特征之间的关系，我们可知互联网协议起初的设计动机仅仅是为了能够提供无连接或报文模式服务而设计的，而人们对互联网协议所期望实现的目标，一定程度上影响着协议的特征，使得互联网协议发展的愈发完善。有时候一些原始想法是很简单的，实际操作中却会变得很复杂；同时，有些在设计者设计之初时考虑的，并不能很好的满足实际用户的需求，如互联网架构的账户、资源管理以及分布式管理操作；有些技术能满足部分设计动机，但却满足不了其他的效果，如报文技术很难处理好资源管理和易读易控的问题。通过分析互联网协议与最初动机的偏差，并分析人们对于互联网协议实现的目标，有助于之后互联网协议的不断完善、进一步发展。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/24/SDN/" data-id="cl77bm6pu000e2kfy0bms3gv0" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-简写" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/18/%E7%AE%80%E5%86%99/" class="article-date">
  <time class="dt-published" datetime="2022-07-18T09:12:07.137Z" itemprop="datePublished">2022-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>CCSDS</p>
<p>ISO</p>
<p>USLP</p>
<p>SCPS</p>
<p>Tm</p>
<p>TC</p>
<p>AOS</p>
<p>MCID</p>
<p>VCID</p>
<p>VC Count</p>
<p>TFVN</p>
<p>SCID</p>
<p>GVCID</p>
<p>MAP ID</p>
<p>RSVD</p>
<p>PDU</p>
<p>APID</p>
<p>SPP</p>
<p>EPP</p>
<p>PVN</p>
<p>EPI</p>
<p>IPE</p>
<p>M_PDU</p>
<p>SNACK</p>
<p>TAO</p>
<p>CC</p>
<p>T&#x2F;TCP</p>
<p>FDU</p>
<p>ARQ</p>
<p>NAK</p>
<p>AMS</p>
<p>CFDP</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/18/%E7%AE%80%E5%86%99/" data-id="cl77bm6pu000d2kfyb21gfv2a" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-线性互补问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/17/%E7%BA%BF%E6%80%A7%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-07-17T09:51:47.902Z" itemprop="datePublished">2022-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线性互补问题"><a href="#线性互补问题" class="headerlink" title="线性互补问题"></a>线性互补问题</h1><p>互补问题(CP)在于发现一个向量</p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/bc3e26a4b1d1e1c3643d79cf9a43dbae.svg" alt="img"></p>
<p>满足以下等式和不等式条件:</p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/14d846b45f6b5bd899db29630e8b719f.svg" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/17/%E7%BA%BF%E6%80%A7%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98/" data-id="cl77bm6q0000f2kfy7p81eg8s" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CFDP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/17/CFDP/" class="article-date">
  <time class="dt-published" datetime="2022-07-17T07:07:48.430Z" itemprop="datePublished">2022-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="CFDP"><a href="#CFDP" class="headerlink" title="CFDP"></a>CFDP</h1><h1 id="2-综述"><a href="#2-综述" class="headerlink" title="2.综述"></a>2.综述</h1><h1 id="2-1大概"><a href="#2-1大概" class="headerlink" title="2.1大概"></a>2.1大概</h1><p>本建议定义了一种适用于在航天器数据存储器之间传输文件的协议。除了纯粹的文件传递相关功能外，该协议还包括文件管理服务，以允许对存储介质进行控制。</p>
<p>该协议能够在各种任务配置中运行，从相对简单的近地轨道航天器到由多个地面设施和传输链路支持的复杂的轨道器和着陆器布置。该协议提供了跨单个成对通信关联操作的核心文件交付能力。当底层的unitdata传输协议提供网络功能时，CFDP的核心文件传递能力可以跨包含多个链路的任意网络传递文件，并且具有不同的可用性。</p>
<p>该协议独立于用于实现数据存储的技术，只需要几个基本的文件存储功能即可运行。它假设有两个文件存储，一个在航天器内，一个在地面上，通过在两个文件存储位置之间复制数据进行操作。</p>
<p>该协议对传输的信息不作任何假设，可用于涉及航天器存储的装载、卸载和控制的广泛应用。</p>
<p>该协议专门设计用于最小化操作所需的资源。它还具有可扩展性，因此只需要实现实现所选选项所需的那些元素。</p>
<p>尽管该协议可以在广泛的基础通信服务上运行，但本建议假设使用参考文献[1]、[2]、[3]、[4]、[7]、[8]和[9]中定义的CCSDS服务</p>
<h2 id="2-2架构元素"><a href="#2-2架构元素" class="headerlink" title="2.2架构元素"></a>2.2架构元素</h2><h3 id="2-2-1大概"><a href="#2-2-1大概" class="headerlink" title="2.2.1大概"></a>2.2.1大概</h3><p>文件交付协议中涉及的架构元素如图2-1所示，如下所述。</p>
<img src="/Users/sunzekun/Library/Application Support/typora-user-images/截屏2022-07-17 上午1.01.21.png" alt="截屏2022-07-17 上午1.01.21" style="zoom:33%;" />

<p>###2.2.2用户</p>
<p>该协议应CFDP用户的请求运行。用户使用第3节中定义的服务原语与协议交互。CFDP用户始终是一个软件任务，可能由人操作，也可能不由人操作。每个CFDP实体最多有一个用户。</p>
<h3 id="2-2-3协议实体"><a href="#2-2-3协议实体" class="headerlink" title="2.2.3协议实体"></a>2.2.3协议实体</h3><p>该协议由核心交付过程的实现组成，允许通过两个实体之间的单个通信关联立即交付和操作文件。向用户提供单个服务界面。</p>
<p>###2.2.4文件存储</p>
<p>该协议通过将文件从存储介质复制到存储介质来运行，因此假设所有CFDP实体都可以访问本地存储能力。由于提供存储能力的方式会有所不同，因此该协议的前提是，任何文件或有组织的文件集（即文件存储）都可以用单个标准表示法来描述。这种称为“虚拟文件存储”的表示被分配了一组标准属性，然后协议使用这些属性来管理文件传递过程。在实现中，虚拟文件存储必须映射到构成真实文件存储的实际硬件和软件，并从中映射。这种方法允许完全独立于用于实现文件存储的技术。</p>
<h3 id="2-2-5底层通信系统"><a href="#2-2-5底层通信系统" class="headerlink" title="2.2.5底层通信系统"></a>2.2.5底层通信系统</h3><p>该协议假设单个概念性底层通信系统可用，称为“单元数据传输（UT）层”，给定CFDP寻址域中的所有CFDP实体都可以访问该层。为了使协议可以在广泛的实现上运行，UT层所需的服务有意地保持尽可能简单；假设这些服务仅在单个概念服务接入点可供任何单个CFDP实体使用。</p>
<p>由于使用的基础服务的潜在多样性，除了识别底层通信系统域内的位置所需的寻址（“UT地址”，可以使用管理信息库中包含的信息将CFDP实体的名称映射到该地址）和CFDP PDU的定界外，不使用对底层协议功能的重用。</p>
<p>CFDP的相对独立性特别意味着支持多个文件传递事务的所有多路复用都发生在CFDP实体内部，序列审计和错误检测由CFDP提供。将PDU长度信息合并到CFDP PDU标头中，以使其独立于底层协议，并简化协议处理。</p>
<p>应该注意的是，尽管CFDP可以在发生数据错误、数据丢失和无序交付的服务上运行，但它并不是为了补偿这些影响普遍存在的网络。如果采用这种方法，将导致严重的性能降低。CFDP绿皮书（CCSDS 720.1-G-1）详细介绍了CFDP性能的简化分析。该分析将允许实现者根据文件大小、文件段大小和误码概率来衡量可能的性能。</p>
<p>###2.2.6管理信息库</p>
<p>要执行文件传递，本地用户必须将大量信息传递给其本地CFDP实体，本地CFDP实体必须将大量信息传递给远程CFDP实体。通常，该数据是静态的，可以作为系统表存储在CFDP实体中，称为管理信息库（MIB）。MIB包含用户通信需求的默认值等信息，例如地址映射和通信计时器设置。MIB在第8节中正式定义为协议规范的一部分。</p>
<h2 id="2-3一般特征"><a href="#2-3一般特征" class="headerlink" title="2.3一般特征"></a>2.3一般特征</h2><h3 id="2-3-1大概"><a href="#2-3-1大概" class="headerlink" title="2.3.1大概"></a>2.3.1大概</h3><p>CFDP支持将文件从一个文件存储区移动到另一个文件存储区，其中两个文件存储区通常驻留在单独的数据系统中，并且通常具有中间的空间链路。在功能上附加到每个这样的文件的可能是大小、格式和语义可变的元数据。元数据由与文件或文件传输相关的信息组成，例如文件名、文件存储请求或发送给CFDP用户的消息。</p>
<p>文件和所有相关元数据的功能连接称为（文件传输单元）FDU，但也允许FDU仅由元数据组成。FDU传输由CFDP实体完成，每个实体只能访问一个文件存储。事务是两个CFDP实体之间单个FDU的端到端传输。事务的启动导致文件复制操作在两个实体（发送方和接收方）之间发生。</p>
<p>如图2-2所示，协议程序构成两个协议实体之间的交互。发送实体是在文件复制操作中从中复制文件的实体。接收实体是在文件复制操作中将文件复制到的实体。</p>
<img src="/Users/sunzekun/Library/Application Support/typora-user-images/截屏2022-07-17 上午1.04.31.png" alt="截屏2022-07-17 上午1.04.31" style="zoom:33%;" />

<p>事务的可靠性取决于事务是选择在未确认模式下运行还是在其中一种已确认模式下运行。在未确认模式下，数据传递故障不会报告给发送方，因此无法修复。因此，CFDP不保证接收完整文件。注意：即使在未确认模式下进行文件传输，使用可靠的底层通信系统在实践中也可以保证完整的文件传递。这种考虑不在CFDP规范的范围内。</p>
<p>注意：即使在未确认模式下进行文件传输，使用可靠的底层通信系统在实践中也可以保证完整的文件传递。这种考虑不在CFDP规范的范围内。</p>
<p>在确认模式下，接收方通知发送方任何未送达的文件段或辅助数据。然后重新传输这些文件，以保证完整的文件传递。</p>
<p>每个事务都会将单个FDU从源复制到目标。在任何单个交易中，可以执行取消、暂停、恢复和报告的子操作。</p>
<p>当下列条件之一适用时，交易终止：</p>
<p>​	–文件已成功传输；</p>
<p>​	–发送或接收实体不允许该交易由于检测到故障，事务已被取消；</p>
<p>​	-源或目标CFDP用户已取消事务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/17/CFDP/" data-id="cl77bm6pp00062kfyddakew1n" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-封装" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/15/%E5%B0%81%E8%A3%85/" class="article-date">
  <time class="dt-published" datetime="2022-07-15T05:24:04.999Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h1><h2 id="1-1目的"><a href="#1-1目的" class="headerlink" title="1.1目的"></a>1.1目的</h2><p>本推荐标准的目的是规定封装数据包协议（EPP）。该协议用于封装使用空间数据链路协议（参考文献[1]-[5]）通过适用的地-空、空-地或空-空通信链路由CCSDS识别的高层协议数据单元。</p>
<h2 id="1-2范围"><a href="#1-2范围" class="headerlink" title="1.2范围"></a>1.2范围</h2><p>本推荐标准根据a）提供给本协议用户的服务原语定义了EPP；b） 服务提供商使用的协议数据单元；和c）服务提供商执行的程序。它没有具体说明a）个别实施或产品；b） 在真实系统中实现服务接口；c） 执行程序所需的方法或技术；ord）配置和控制服务所需的管理活动。</p>
<h2 id="1-3适用性"><a href="#1-3适用性" class="headerlink" title="1.3适用性"></a>1.3适用性</h2><p>本推荐标准适用于机构标准的制定以及交叉支援情况下CCSDS机构之间未来的空间链路数据通信。建议的标准包括机构间交叉支助服务的全面规范。它既不是可用于现有或未来任务的真实系统的规范，也不是针对真实系统的设计。本文件中规定的推荐标准将通过每个CCSDS机构的正常标准程序调用，并适用于预期基于本推荐标准中描述的能力进行交叉支持的任务。如果在推荐标准的章节中明确指出了强制性能力，则当本文件用作交叉支持的基础时，必须实施强制性能力。在允许或暗示选择的情况下，这些选择的实施取决于相关机构之间的具体双边交叉支持协议。</p>
<h2 id="1-4基本原理"><a href="#1-4基本原理" class="headerlink" title="1.4基本原理"></a>1.4基本原理</h2><p>CCSDS空间数据链路协议主要用于传输可直接插入协议数据字段的应用层数据。为了允许这些空间数据链路协议承载其他协议数据单元，例如网络互连协议或文件传输或消息传输协议，设计了一个“填充”协议来明确指定如何执行。</p>
<h1 id="2概述"><a href="#2概述" class="headerlink" title="2概述"></a>2概述</h1><p>##2.1封装包协议的概念</p>
<p>EPP用于传输CCSD识别的协议数据单元（参考文献[9]和[10]），这些数据单元不是通过适用的地对空、空对地或空对空通信链路由空间数据链路协议（参考文献[1]-[5]）直接传输的。可通过空间数据链路协议直接传输的数据单元具有CCSDS授权的数据包版本号（PVN）。（CCSDS目前授权的数据包版本号列表包含在参考文献[8]中。）EPP的主要目的是提供一种机制，在没有授权PVN的情况下通过空间链路传输协议数据单元。EPP是一种“shim”协议，利用参考文献[1]-[5]中定义的数据链路层的空间数据链路协议的分组服务，因此拟与这些参考文献之一一起使用。</p>
<p>![截屏2022-07-15 上午11.02.25](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 上午11.02.25.png)</p>
<p>图2-1说明了该协议的概念。没有授权PVN的协议X和Y的协议数据单元在数据链路层内与EPP一起传输。协议X和Y的协议数据单元封装在本文件4.1中定义的封装数据包中，并最终使用空间数据链路协议的VC&#x2F;MAP&#x2F;Proximition-1数据包服务之一进行传输。管理层应确定用于传输封装协议数据单元的空间数据链路协议。</p>
<h2 id="2-2封装包协议的特点"><a href="#2-2封装包协议的特点" class="headerlink" title="2.2封装包协议的特点"></a>2.2封装包协议的特点</h2><p>EPP通过空间链路在空间数据链路协议的数据字段内传输可变长度、定界、八位字节对齐的协议数据单元序列。该协议的用户是一个协议实体，它发送或接收没有授权PVN的协议数据单元。</p>
<p>协议用户提供的数据单元未经更改地封装到封装包中，单个数据单元封装到单个包中。</p>
<p>该协议允许数据单元的长度为八位字节的整数，并且受项目组织确定的最大和最小尺寸的限制。尽管封装数据包可以容纳的数据单元的最大长度为4294967287个八位字节，但个别项目组织可以为封装的数据单元确定最大和最小大小。</p>
<p>向用户提供该协议实例的点称为服务接入点（SAP）（参考文献[6]）。提交给SAP的数据单元按提交顺序进行处理。对于提交给不同SAP的数据单元，不维护处理顺序。</p>
<p>注意：可能需要在SAP上实施服务用户和服务提供商之间的流控制。然而，CCSDS不建议用户和提供商之间的流量控制方案。</p>
<p>EPP的特点如下：</p>
<p>源端系统的封装包协议实体从源用户应用程序提供的协议数据单元生成封装包。数据传输是单向的，即连接的一端可以通过空间链路发送但不接收数据，而另一端可以通过空间链路接收但不发送数据。用户提供的数据单元的传输与数据链路层内的任何数据传输机制之间不存在定时关系。用户可以随时请求数据传输，但服务提供商可能会对数据生成速率施加限制。此外，在用户提供的协议数据单元的传输和数据链路层内的任何数据传输机制之间不存在定时关系。用户可以随时请求数据传输，但底层服务提供商可能会对数据生成速率施加限制。虽然封装。指示原语确认收到封装。从用户请求时，发送用户没有收到来自接收端的指示数据已被接收的确认。此外，无法保证数据已完全传输，但服务提供商可能会在交付给接收用户的数据单元序列中发出间隙信号。最后，发送用户提供的数据单元序列通过空间链路上的传输得以保留，尽管交付给接收用户的数据单元序列中可能存在间隙。</p>
<p>##2.3地址</p>
<p>EPP的用户由封装协议标识符（EPI）标识。封装数据包是本文件第4节中定义的协议数据单元。封装协议标识符在参考文献[9]中注册为“定义的协议ID”。SAP通过PVN、EPI和空间数据链路协议（SDLP）通道的组合来识别，用户提供的数据单元将通过该通道传输。</p>
<h2 id="2-4协议描述"><a href="#2-4协议描述" class="headerlink" title="2.4协议描述"></a>2.4协议描述</h2><p>根据</p>
<p>a）提供给本协议用户的原语描述EPP；</p>
<p>b） 协议用于封装的协议数据单元；和</p>
<p>c）协议执行的程序。这些原语提供了服务提供者和服务用户之间数据和控制信息逻辑交换的抽象模型。</p>
<p>原语的定义独立于具体的实现方法。</p>
<p>协议数据单元（即封装包）定义了封装服务用户提供的数据单元的数据结构。</p>
<p>程序规范定义了服务提供商为传输数据单元而执行的程序。</p>
<p>程序的定义独立于具体的实现方法或技术。</p>
<h1 id="3服务定义"><a href="#3服务定义" class="headerlink" title="3服务定义"></a>3服务定义</h1><h2 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h2><p>本节以原语的形式提供服务定义，它提供了服务提供者和服务用户之间数据和控制信息逻辑交换的抽象模型。原语的定义独立于具体的实现方法。原语的参数以抽象意义指定，并指定要提供给原语用户的信息。特定实现提供此信息的方式不受本规范的约束。除了本节中指定的参数外，实现还可以向服务用户提供其他参数（例如，用于控制服务、监测性能、促进诊断等的参数）。</p>
<h2 id="3-2参数"><a href="#3-2参数" class="headerlink" title="3.2参数"></a>3.2参数</h2><p>NOTE–EPP原语使用的参数在第3.2.1至3.2.3小节中描述。</p>
<h3 id="3-2-1数据单元"><a href="#3-2-1数据单元" class="headerlink" title="3.2.1数据单元"></a>3.2.1数据单元</h3><h4 id="3-2-1-1参数数据单元是由EPP传输的服务数据单元，它应该是一个分隔的、八位字节对齐的数据单元。"><a href="#3-2-1-1参数数据单元是由EPP传输的服务数据单元，它应该是一个分隔的、八位字节对齐的数据单元。" class="headerlink" title="3.2.1.1参数数据单元是由EPP传输的服务数据单元，它应该是一个分隔的、八位字节对齐的数据单元。"></a>3.2.1.1参数数据单元是由EPP传输的服务数据单元，它应该是一个分隔的、八位字节对齐的数据单元。</h4><h4 id="3-2-1-2尽管封装数据包中可容纳的数据单元的最大长度为4294967287个八位字节，但单个项目组织可以为封装数据单元确定最大和最小尺寸。"><a href="#3-2-1-2尽管封装数据包中可容纳的数据单元的最大长度为4294967287个八位字节，但单个项目组织可以为封装数据单元确定最大和最小尺寸。" class="headerlink" title="3.2.1.2尽管封装数据包中可容纳的数据单元的最大长度为4294967287个八位字节，但单个项目组织可以为封装数据单元确定最大和最小尺寸。"></a>3.2.1.2尽管封装数据包中可容纳的数据单元的最大长度为4294967287个八位字节，但单个项目组织可以为封装数据单元确定最大和最小尺寸。</h4><p>###3.2.2SDLP_信道3.2.2.1参数SDLP_信道是EPP的SAP地址的一部分，它应唯一标识传输协议数据单元的底层SDLP的信道。3.2.2.2SDLP_信道的内容取决于底层SDLP服务：a）对于TM（参考文献[1]）、TC（参考文献[2]）或AOS（参考文献[3]）的虚拟信道分组（VCP）服务，SDLP_信道应包含全局虚拟信道标识符（GVCID）；b） 对于TC（参考文献[2]）和USLP（参考文献[5]）的MAP数据包（MAPP）服务，SDLP_信道应包含全局MAP ID（GMAP ID）；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/15/%E5%B0%81%E8%A3%85/" data-id="cl77bm6pt000b2kfyafo27mgi" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SPP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/15/SPP/" class="article-date">
  <time class="dt-published" datetime="2022-07-15T03:00:17.273Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h1><h2 id="1-1目的"><a href="#1-1目的" class="headerlink" title="1.1目的"></a>1.1目的</h2><p>本推荐标准的目的是规定空间分组协议。<strong>空间任务将使用该协议，依靠底层提供的服务，在发送实体和接收实体之间传输空间应用数据。</strong></p>
<h2 id="1-2范围"><a href="#1-2范围" class="headerlink" title="1.2范围"></a>1.2范围</h2><p>本推荐标准根据a）向本协议用户提供的抽象服务定义了空间包协议；b） 协议使用的协议数据单元（PDU）；和c）协议执行的程序。它没有规定a）单个实现或产品；b） 在真实系统中实现服务接口；c） 执行程序所需的方法或技术；ord）配置和控制协议所需的管理活动。</p>
<h2 id="1-4理论基础"><a href="#1-4理论基础" class="headerlink" title="1.4理论基础"></a>1.4理论基础</h2><p>在许多空间应用中，具有单一、通用的应用层数据结构对于创建、存储和传输可变长度的应用层数据具有重要价值。这种数据结构可以在船上交换和存储，通过一个或多个空间数据链路传输，并在地面系统中使用。通常有必要确定此类数据的类型、来源和&#x2F;或目的地。</p>
<p>![截屏2022-07-15 下午3.00.34](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 下午3.00.34.png)</p>
<h1 id="2概述"><a href="#2概述" class="headerlink" title="2概述"></a>2概述</h1><h2 id="2-1空间数据包协议的概念"><a href="#2-1空间数据包协议的概念" class="headerlink" title="2.1空间数据包协议的概念"></a>2.1空间数据包协议的概念</h2><h3 id="2-1-1架构"><a href="#2-1-1架构" class="headerlink" title="2.1.1架构"></a>2.1.1架构</h3><p><strong>空间数据包协议（SPP）设计为数据单元（即空间数据包）的自分隔载体，其中包含用于识别指定设备的数据内容、数据源和&#x2F;或数据用户的APID。典型用途是将数据从特定任务源传输给任务用户。不同的数据类型不需要额外的信息（如时间）来充分利用所包含的数据，这些参数和数据内容的格式必须在任务环境中使用APID来识别。</strong></p>
<p><strong>SPP旨在满足空间任务的要求，通过一个或多个子网络在节点之间高效传输各种类型和特性的空间应用数据，可能涉及一个或多个地对空、空间对地、空间对空间或车载通信链路。</strong></p>
<p><strong>图2-1说明了SPP在协议栈中的位置。SPP能够提供应用层协议或“shim”协议的功能。因此，SPP框在该图中出现了两次。在应用层，SPP定义了空间数据包，用户可以直接使用该空间数据包来包含应用程序数据。此外，SPP类似于封装包协议（EPP）（参考文献[C8]），可以提供“shim”协议的功能。</strong></p>
<p><strong>APID对来源或目的地的意义以及SPP将穿越的路径的识别完全取决于在任何给定部署背景下任务特定意义的分配。最重要的是，SPP本身没有定义路径、网络或路由功能，也不提供网络服务。此外，SPP本身没有联网能力，完全依赖于适用子网提供的服务。</strong></p>
<p>图2-1说明了在空间链路上使用CCSDS协议堆栈中的SPP概念。用户数据单元被合并到4.1中定义的空间数据包中，并最终使用空间数据链路协议（参考文献[C3]、[C4]、[C5]、[C7]和[C6]）或捆绑协议（BP）服务（参考文献[C9]）的其中一个包服务在空间链路上传输，该服务将捆绑传输到已识别的捆绑端点。管理层确定要用于传输PDU的底层协议和服务。数据链路层的编码和同步子层此处省略。</p>
<p><strong>SPP通过一个或多个子网提供从单个源用户应用程序到一个或多个目标用户应用程序的单向数据传输服务。在本文中，用户应用程序旨在生成（或接收）具有唯一APID的空间数据包。</strong></p>
<p><strong>APID在给定的任务部署中提供单个命名域。根据任务需要，任务可以以多种方式使用APID。它可以用于指定数据包流的预期目的地、指定数据包流的源或指定不同类型的数据包。APID的使用方式和APID命名域的管理都是特定于任务的选择。</strong></p>
<p>如果任务希望使用APID命名域来服务，例如，具有多个处理器的航天器、“分离”的航天器，甚至包括部署多个航天器的任务，这些任务必须在企业内的单个APID命名域中管理和子分配分配分配，或者定义一种方法，使用数据包二级报头中的任务特定字段扩展分配。APID和辅助标头支持这种扩展，但在本协议中没有定义。</p>
<p><strong>当数据穿过子网时，它们由使用子网提供的协议的子网特定机制携带。子网中使用的协议的选择是为每个子网独立确定的，并且在整个过程中可能不相同。</strong></p>
<p>通过端到端数据系统的实际路径，在数据传输发生之前，需要通过设计或管理系统配置数据包流，并且只能通过管理系统重新配置数据包流。该流被称为托管数据路径；除了APID之外，SPP没有定义任何机制来定义或管理托管数据路径。每个受管数据路径可以由单个源端系统、一个或多个目标端系统、一个或多个子网以及（如果涉及多个子网）一个或多个互连子网的中间系统组成。仅当源和目标端系统位于同一子网络上时，受管数据路径仅涉及一个子网络。SPP实体不知道托管数据路径和任何底层传输服务的配置详细信息。这些都是这些基础服务的责任，SPP直接提供的唯一信息是APID领域。</p>
<h3 id="2-1-2协议特征"><a href="#2-1-2协议特征" class="headerlink" title="2.1.2协议特征"></a>2.1.2协议特征</h3><p>空间应用程序为用户提供抽象服务，将空间应用程序数据从源传输到目标用户应用程序。该协议执行的主要功能是识别和封装应用程序数据，以促进其通过底层子网沿着受管数据路径传输。</p>
<p>本协议使用的PDU是空间数据包（除非另有说明，本文件中的术语“数据包”是指空间数据包）。它们的长度是可变的（或者可以由用户自行决定固定），并以可变的间隔传输。除了识别数据包的SPP报头之外，空间数据包的内部数据内容完全由用户应用程序控制。每个用户应用程序都可以独立于其他用户应用程序定义数据包的组织和内容，并具有底层子网传输机制施加的最小约束。</p>
<p>源端系统中的SPP实体要么从源用户应用程序提供的服务数据单元（SDU）生成空间数据包，要么验证由源用户应用程序提供的空间数据包（作为SDU）。在源系统，SPP实体检查传入空间数据包的APID，并使用底层协议和通信系统提供的服务通过适当的子网传输它们。中间节点的行为以及用于转发数据的过程是特定实现的，不在本文档的范围内。如果空间分组有多个目的地，则空间分组的多播可由源端系统和&#x2F;或中间系统的一个或多个SPP实体执行。</p>
<h3 id="2-1-3-寻址"><a href="#2-1-3-寻址" class="headerlink" title="2.1.3 寻址"></a>2.1.3 寻址</h3><p>SPP内的寻址功能是APID。APID仅在单个命名域中是唯一的。一个APID命名域通常对应于一个航天器（或合作航天器星座的一个元素）。每个空间项目都建立了在其命名域中APID的分配方案。命名域内的APID分配给管理的数据路径，是由拥有命名域的空间项目控制的。</p>
<h3 id="2-1-4协议描述"><a href="#2-1-4协议描述" class="headerlink" title="2.1.4协议描述"></a>2.1.4协议描述</h3><p>SPP描述为</p>
<p>a）向用户提供的抽象服务；</p>
<p>b） PDU；和</p>
<p>c）协议执行的程序。</p>
<p>服务定义以原语的形式给出，它提供了协议实体和服务用户之间数据和控制信息逻辑交换的抽象模型。原语的定义独立于具体的实现方法。程序规范定义了协议实体为在对等实体之间传输信息而执行的程序。程序的定义独立于具体的实现方法或技术。</p>
<p>##2.2服务概述</p>
<h3 id="2-2-1服务的常见特征"><a href="#2-2-1服务的常见特征" class="headerlink" title="2.2.1服务的常见特征"></a>2.2.1服务的常见特征</h3><p>SPP为用户提供数据传输服务。协议实体向用户提供服务的点称为SAP（见参考文献[1]）。SPP实体的SAP接受用APID标识的SPP SDU。</p>
<p>提交给SAP的SDU按提交顺序进行处理。对于提交给不同SAP的SDU，不维护处理顺序。</p>
<p>注意：SAP可能需要服务用户和服务提供商之间的流量控制。然而，CCSDS并没有定义用户和提供者之间的流量控制方案。</p>
<p>本推荐标准中的服务类别包括以下内容：</p>
<p>a）预配置服务：用户只能通过管理层建立的预配置托管数据路径发送或接收数据。</p>
<p>b） 单向（单向）服务：托管数据路径的一端可以通过该路径发送但不接收数据，而另一端可以接收但不发送。</p>
<p>c） 异步服务：对于服务用户提供的SDU的传输，没有预定义的定时规则。用户可以在其希望的任何时间请求数据传输，但提供者实现可能会对数据生成速率施加限制。</p>
<p>d） 未确认服务：发送用户没有从接收端收到数据已接收的确认。</p>
<p>e） 不完整服务：这些服务不保证SDU序列的完整性，也不提供重传机制。</p>
<p>f） 非序列保留服务：发送用户提供的SDU序列可能无法通过端到端托管数据路径保留。</p>
<p>注意：该协议可用于从用户A向用户B和从用户B向用户A发送数据，但在这种情况下，应使用两条单独的受管数据路径，每个方向一条。</p>
<p>提供给服务用户的实际端到端服务质量将根据受管数据路径沿线的不同子网提供的个别服务质量而有所不同。SPP不提供任何保证特定服务质量的机制；实现组织有责任确保特定服务实例的端到端性能满足其用户的要求。</p>
<h3 id="2-2-2服务概述"><a href="#2-2-2服务概述" class="headerlink" title="2.2.2服务概述"></a>2.2.2服务概述</h3><h4 id="2-2-2-1概述"><a href="#2-2-2-1概述" class="headerlink" title="2.2.2.1概述"></a>2.2.2.1概述</h4><p>SPP提供两种服务：分组服务和八进制字符串服务。表2-1总结了这些服务。</p>
<p>![截屏2022-07-15 上午12.38.06](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 上午12.38.06.png)</p>
<p>SPP服务提供商实体的每个源或目标SAP都有一个相关的服务类型，即数据包或八位字节字符串。服务类型不需要从受管数据路径的端到端保留；也就是说，可以提供非对称服务。例如，在源端系统调用八位字节字符串服务可能（应用户请求）导致通过相同受管数据路径的目标端系统的分组服务实例交付数据。</p>
<p>注：如2.1.2所述，SPP生成的PDU是两种服务类型的空间包。在分组服务的情况下，相同的空间分组同时用作SDU和PDU。</p>
<h4 id="2-2-2-2包服务"><a href="#2-2-2-2包服务" class="headerlink" title="2.2.2.2包服务"></a>2.2.2.2包服务</h4><p>包服务通过托管数据路径完整地传输由服务用户预先格式化的空间包。服务用户必须根据本推荐标准第4.1小节中给出的规范生成空间包。服务用户提供的空间数据包由服务提供商传输，格式没有任何更改。</p>
<h4 id="2-2-2-3八位字节字符串服务"><a href="#2-2-2-3八位字节字符串服务" class="headerlink" title="2.2.2.3八位字节字符串服务"></a>2.2.2.3八位字节字符串服务</h4><p>八位字节字符串服务通过托管数据路径传输服务用户提供的八位字节的分隔字符串。服务提供商通过将八进制字符串格式化为空间数据包来传输它们。此格式的详细信息由管理层设置。</p>
<h2 id="2-3功能概述"><a href="#2-3功能概述" class="headerlink" title="2.3功能概述"></a>2.3功能概述</h2><h3 id="2-3-1一般功能"><a href="#2-3-1一般功能" class="headerlink" title="2.3.1一般功能"></a>2.3.1一般功能</h3><p>SPP使用底层子网的服务传输发送用户提供的SDU，产生称为空间数据包的PDU序列。空间数据包具有可变长度，并通过子网异步传输。</p>
<p>协议实体执行以下协议功能：</p>
<p>a）生成（或验证）和处理包含在报头中的协议控制信息，以执行数据识别；</p>
<p>b） 通过一系列底层子网络启动PDU传输；</p>
<p>c） 多路复用&#x2F;解多路复用，以便各种服务用户（即各种受管数据路径）共享由底层子网提供的物理连接。</p>
<p>协议实体不执行以下任何协议功能：</p>
<p>a）连接建立和释放；</p>
<p>b） SDU的分割；</p>
<p>c） 重新传输丢失的SDU；</p>
<p>d） 流量控制；</p>
<p>e） 服务质量特征。</p>
<h3 id="2-3-2协议实体的内部组织"><a href="#2-3-2协议实体的内部组织" class="headerlink" title="2.3.2协议实体的内部组织"></a>2.3.2协议实体的内部组织</h3><p>图2-2和2-3分别显示了发送和接收系统的协议实体的内部组织。在图2-2中，数据从图的顶部流向底部。在图2-3中，数据从底部流向顶部。这些图确定了协议实体执行的数据处理功能。这些图的目的是显示协议实体功能之间的逻辑关系。这些图并不意味着实际系统中的任何硬件或软件配置。根据实际系统提供的服务，并非所有功能都存在于协议实体中。</p>
<p>![截屏2022-07-15 上午12.39.25](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 上午12.39.25.png)</p>
<h2 id="2-4从较低层假设的服务"><a href="#2-4从较低层假设的服务" class="headerlink" title="2.4从较低层假设的服务"></a>2.4从较低层假设的服务</h2><p>如2.1.1所述，SPP使用底层提供的服务。其目的是使SPP能够在各种真实子网和数据链路提供的服务上运行。此外，SPP本身没有联网能力，完全依赖于适用子网提供的服务。</p>
<p>在本规范中，假设底层子网及其相关协议提供了执行空间包PDU从源到目标的传输所需的本地寻址、存储和转发能力。</p>
<p>当在空间链路上运行时，SPP依赖于空间数据链路协议（即TM、TC、AOS、接近度-1和USLP，参考文献[C3]-[C7]）提供的分组服务，或依赖于将包传输到BP提供的已识别包端点的服务（参考文献[C9]）。虽然BP提供联网能力，但空间数据链路协议仅用于点对点通信。</p>
<p>SPP还可以在许多其他通信链路上运行，例如，可以通过SOIS分组服务（参考文献[C12]）在仪器和数据存储器之间、通过本地消息总线或专用数据交换在S&#x2F;C内、通过本地消息总线或专用数据交换在地面系统内使用，通过地面TCP&#x2F;IP套接字链接作为数据流等。</p>
<h1 id="SPP-Overview"><a href="#SPP-Overview" class="headerlink" title="SPP Overview"></a>SPP Overview</h1><p>每个受管数据路径仅提供从源用户应用程序到一个或多个目标用户应用程序的单向传输。航天器上的用户应用程序通常接收来自其他用户应用程序的命令，并将遥测数据发送回发送命令的原始用户应用程序。在这种情况下，用于发送遥测的受管数据路径与用于发送命令的受管数据路径是分开的</p>
<p>空间分组协议不在单个受管数据路径上提供对等用户应用程序之间的双向通信，但这并不是一个很大的缺点，因为空间任务的命令和遥测数据流并不总是对称的（通常从航天器接收遥测数据的用户应用程序的数量远大于向同一航天器发送命令的用户应用程序的数量）。</p>
<p>##2.5空间分组协议标称示例</p>
<p>本节展示了如何使用空间数据包协议操作车载仪器的示例。</p>
<h3 id="用户应用程序的配置"><a href="#用户应用程序的配置" class="headerlink" title="用户应用程序的配置"></a>用户应用程序的配置</h3><p>假设航天器上的仪器拍摄图像并将其发送到位于地面的图像分析系统。仪器根据从地面控制系统接收的命令拍摄图像，并将其状态发送回控制系统。</p>
<p>该仪器有两个用户应用程序：一个用于监测和控制自身，另一个用于预处理（例如压缩等）拍摄的图像。图像预处理过程与分析系统中的图像分析过程通信，监控过程与控制系统中的仪器操作过程通信。</p>
<p>该系统的用户应用程序配置如图2-2所示。在该图中，有三个物理实体，如方框所示：仪器、控制系统和分析系统。该仪器位于航天器上，而控制和分析系统位于地面的空间操作中心。该系统中的四个用户应用程序显示为椭圆形。</p>
<p>这项任务还涉及其他元素，但图中未显示这些元素。例如，航天器上有其他仪器和子系统，地面上有其他支持设施（如跟踪网络）。图2-2仅显示了直接执行该仪器操作的元件。该仪器的用户应用程序几乎可以独立于任务中涉及的其他元素进行设计。</p>
<h3 id="用户应用程序之间的通信"><a href="#用户应用程序之间的通信" class="headerlink" title="用户应用程序之间的通信"></a>用户应用程序之间的通信</h3><p>仪器的图像预处理过程通过受管数据路径1将预处理的图像发送到地面的图像分析过程。图像通过打包在空间数据包中的空间数据包协议传输。然而，由于拍摄图像的大小通常大于空间数据包的最大大小，因此必须在一组空间数据包中传输图像。源用户应用程序（本例中的图像预处理过程）必须将图像分成更小的段，并确保每个段都适合一个空间数据包。底层传输机制对传输速率有限制，但在该限制范围内，车载预处理过程可以在其希望发送的时间发送任何大小的图像。因此，预处理过程可以使用适当的方法压缩图像，并在有图像要发送时发送它们。</p>
<p>地面上的仪器操作过程通过托管数据路径2向仪器的监控过程发送控制仪器的命令。当仪器从地面实时控制时，每个单独的命令都在一个空间数据包中传输。当仪器根据地面生成的观测计划自主执行观测时，每个观测计划都在空间数据包中传输。</p>
<p>仪器的监测和控制过程通过受管数据路径3定期将仪器的状态发送到地面的仪器操作过程。一次获取的一组状态数据在空间分组中传输。</p>
<p>无论航天器是否与地面接触，该仪器都会生成图像和状态数据。当航天器不与地面接触时，图像和状态数据临时存储在航天器上的机载数据存储器中。当航天器与地面接触时，存储的数据传输到地面。这些“存储和转发”操作作为管理数据路径内的管理操作执行，仪器无需知道数据是实时传输到地面还是存储在车载数据存储器中。</p>
<p>该仪器的用户应用程序的设计假设了如何使用托管数据路径，但仪器设计者不必关心空间数据包如何通过底层子网进行物理传输，也不必关心它们临时存储的位置和方式。</p>
<p>如果底层子网没有提供足够的可靠性，则用户应用程序可以使用这三条或其他受管数据路径实现可靠的传输机制。例如，仪器可以通过受管数据路径3将其通过受管数据路径2接收到的每个命令的接收确认返回给控制系统，以便控制系统可以重新发送丢失的命令。</p>
<p>![截屏2022-07-15 下午2.54.09](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 下午2.54.09.png)</p>
<h1 id="3什么是封装包协议-从用户的角度"><a href="#3什么是封装包协议-从用户的角度" class="headerlink" title="3什么是封装包协议-从用户的角度"></a>3什么是封装包协议-从用户的角度</h1><h2 id="3-1封装包协议的基本概念"><a href="#3-1封装包协议的基本概念" class="headerlink" title="3.1封装包协议的基本概念"></a>3.1封装包协议的基本概念</h2><p>封装包协议（EPP）用于通过适用的地对空、空对地或空对空通信链路，使用空间数据链路协议（参考文献[3]-[7]）传输CCSD在SANA中识别的协议数据单元。可通过空间数据链路协议直接传输的数据单元具有在SANAby CCSDS中定义的数据包版本号（PVN）。（CCSDS目前定义的数据包版本号列表包含在参考文献[15]中）。EPP的主要目的是提供一种机制，在没有授权PVN的情况下通过空间链路传输协议数据单元。</p>
<p>EPP是一种“填充”协议，利用参考文献[3]-[7]中定义的数据链路层的空间数据链路协议的分组服务，因此打算与这些参考文献之一一起使用。</p>
<p>![截屏2022-07-16 下午7.52.07](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-16 下午7.52.07.png)</p>
<p>图3-1说明了本协议的概念。没有授权PVN的协议X和Y的协议数据单元在数据链路层内与EPP一起传输。协议X和Y的协议数据单元封装在封装数据包中，并最终使用空间数据链路协议的VC&#x2F;MAP&#x2F;Proxity-1包服务之一进行传输。管理层应确定用于传输封装协议数据单元的空间数据链路协议。图2-1还提供了EPP作为CCSDS上层协议和CCSDS空间数据链路层之间的填充层协议的更全面视图。</p>
<h2 id="3-2封装包协议的特点"><a href="#3-2封装包协议的特点" class="headerlink" title="3.2封装包协议的特点"></a>3.2封装包协议的特点</h2><p>EPPT通过空间链路在空间数据链路协议的数据字段内传输可变长度、定界、八位字节对齐的协议数据单元序列。该协议的用户是发送或接收没有授权数据包版本号（PVN）的协议数据单元的协议实体。</p>
<p>协议用户提供的数据单元原封不动地封装到封装包中，并且只有一个数据单元封装到单个包中。</p>
<p>该协议允许数据单元的长度为八位字节的整数，并且受项目组织确定的最大和最小大小的限制。尽管封装数据包可以容纳的数据单元的最大长度为4294967287个八位字节，但个别项目组织可以为封装的数据单元确定最大和最小大小。</p>
<p>向用户提供该协议实例的点称为服务接入点（SAP）（参考文献[16]）。提交给SAP的数据单元按提交顺序进行处理。对于提交给不同SAP的数据单元，不维护处理顺序</p>
<p>注意：可能需要在SAP上实施服务用户和服务提供商之间的流控制。然而，CCSDS不建议用户和提供商之间的流量控制方案。</p>
<p>EPP的特点如下：</p>
<p>a） 单向（单向）服务：连接的一端可以通过空间链路发送但不接收数据，而另一端可以通过空间链路接收但不发送数据。</p>
<p>b） 异步服务：在用户提供的数据单元传输和数据链路层内的任何数据传输机制之间没有时间关系。用户可以随时请求数据传输，但服务提供商可能会对数据生成速率施加限制。</p>
<p>c） 未确认服务：发送用户未收到来自接收端的确认，表明已收到数据。</p>
<p>d） 不完整服务：服务不保证完整性，但服务提供商可能会在交付给接收用户的数据单元序列中发出缺口信号。</p>
<p>e） 序列保留服务：发送用户提供的数据单元序列通过空间链路传输来保留，尽管交付给接收用户的数据单元序列中可能存在间隙。</p>
<h2 id="3-3寻址"><a href="#3-3寻址" class="headerlink" title="3.3寻址"></a>3.3寻址</h2><p>EPP的用户由封装协议标识符（EPI）标识。封装包是参考文献[2]第4节中定义的协议数据单元。<br>封装协议标识符在SANA注册中心协议ID[17]和扩展EPI[18]中注册为“定义的协议ID”。SAP通过PVN、EPI和空间数据链路协议（SDLP）通道的组合来识别，用户提供的数据单元将通过该通道传输。</p>
<h2 id="3-4协议描述"><a href="#3-4协议描述" class="headerlink" title="3.4协议描述"></a>3.4协议描述</h2><p>EPP描述如下：</p>
<p>a） 提供给本协议用户的原语；</p>
<p>b） 协议用于封装的协议数据单元；and</p>
<p>c）协议执行的程序。</p>
<p>这些原语提供了服务提供者和服务用户之间数据和控制信息逻辑交换的抽象模型。原语的定义独立于具体的实现方法。</p>
<p>协议数据单元（即封装包）定义了封装服务用户提供的数据单元的数据结构。</p>
<p>程序规范定义了服务提供商为传输数据单元而执行的程序。程序的定义独立于具体的实现方法或技术。</p>
<h2 id="3-5封装包协议部署示例"><a href="#3-5封装包协议部署示例" class="headerlink" title="3.5封装包协议部署示例"></a>3.5封装包协议部署示例</h2><p>示例说明了如何将封装数据包协议用作填充协议，以封装CCSDS文件传输协议（CFDP）协议数据单元，并使用图3-2所示的底层CCSDS空间数据链路层跨空间链路传输。</p>
<p>![截屏2022-07-16 下午7.56.43](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-16 下午7.56.43.png)</p>
<p>为了在地面和&#x2F;或飞行系统上实现的文件存储之间以图3-2所示的任一方向传输文件，用户选择CFDP作为上层协议。该文件的内容被转换为一系列CFDP协议数据单元（PDU），这些数据单元在封装数据包中逐个封装。分配给封装数据包标头的EPI将CFDP识别为封装协议，因此在接收端，封装数据包的内容将路由到接收CFDP引擎。将一个或多个封装包放入给定空间数据链路的适用CCSDS传输帧中。空间数据链路层位于物理层之上，即射频或光链路</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/15/SPP/" data-id="cl77bm6ps00092kfyafys1k73" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IP Over CCSDS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/15/IP%20Over%20CCSDS/" class="article-date">
  <time class="dt-published" datetime="2022-07-15T02:25:35.351Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>随着空间应用的发展，空间通信模式也在不断地变革。由单个航天器采集数 据、经由航天机构的控制中心发往用户的模式，将转变为航天器之间以及航天器 与地面任一用户之间进行的任意通信方式。由于空间和地面底层链路的差异，所 以不可能在链路层采用相同的协议，但网络层可以屏蔽此差异。如果空间和地面 采用不同的网络协议，那么地面与空间通信时，要么采用协议转换的方式，要么 采取隧道的方式，并且由于航天器的移动性会使两个协议交互复杂性大大增加， 显然地面和空间采用一致的网络协议会大大简化它们之间的通信，同时也可带来 其他诸多的好处，例如简化和优化拓扑发现和路由选择，利用成熟的技术降低成 本等等，从而使整个通信系统的健壮性和可扩展性大大增强。</p>
<p>地面上 IP 协议是用户普遍采用的通信协议，采用此协议的网络已互联构成 遍布全球的因特网，空间如果能够应用 IP 协议，那么可以使地面和空间的通信 从网络层开始采用基本上一致的协议，从而可以从网络层开始提供一体化的端到 端通信服务，不但可以有效地利用现有的因特网基础设施，而且可以利用现有的IP 技术和产品，使空间任务的成本大幅度降低。<br> 综上原因，结合 1.3 节对空间数据通信协议 CCSDS 的分析，本文提出基于IP over CCSDS 的空间通信网络设计模式，即在空间通信的数据链路层采用 CCSDS AOS 协议，在网络层采用 IP 技术。一方面因为 CCSDS 在空间通信中的 优秀性能使其具有其他协议不可比拟的优势，已成为空间通信事实上的标准。从 我国航天技术的发展来看，CCSDS 标准满足我国未来空间任务的需要，航天技 术要解决面临的问题，开展空间任务的国际合作，航天测控通信与数据系统体制 就一定要与 CCSDS 标准接轨;另一方面，未来空间通信将与地面通信融为一体， 实现任意两点之间的端到端通信，而 IP 协议正是这一融合的基础和催化剂。目 前，IP 技术已在地面无线网络中得到了充分的试验验证，而空间通信作为无线 通信的一个特例，采用经过验证的 IP 技术，并在此基础上开发适应空间环境的 解决方案，将使得未来空间飞行器通过无线信道与地面因特网无缝连接，实现遥 科学的目的，同时可以降低空间任务的成本和风险[20]。</p>
<p>总之，CCSDS 协议是专为空间通信“量身定做”的协议，在解决空间通信 中面临的误码率高、传输延迟、带宽非对称的等方面具有其独特优势。积极研究 和采用 IP over CCSDS 的空间通信网络体系，提高测控通信网信息传输性能，可 以有效地处理航天测控通信网面临的一些难题，如:</p>
<ul>
<li>基于 IP over CCSDS 模式，星上多个有效载荷或者多个卫星联网，解决 数据端到端实时、可靠的传输;</li>
<li>解决航天器的同时空地双向高质量传递话音、图像、高速实验和观测， 以及传统的 TT&amp;C 等多种速率和形式的数字信息的需求;</li>
<li>星上和地面设备具备重新组配的动态调整能力，为多部门、多任务提供 多种数字信息;</li>
<li>支持实现TDRSS星间和星地射频链路前、返向高速率数据传输的功能;</li>
<li>为多种形式的复杂的国际性航天任务合作提供统一的航天数据系统;</li>
<li>为建设我国的天基综合信息网奠定必要的技术基础。<br>   关于 IP over CCSDS 空间组网通信模式的深入分析详见第三章。</li>
</ul>
<h1 id="2概述"><a href="#2概述" class="headerlink" title="2概述"></a>2概述</h1><p>##2.1概述</p>
<p>本文件描述了通过CCSDS SDLP传输IP PDU的推荐方法：遥控（TC）、遥测（TM）、先进轨道系统（AOS）和接近-1（Prox-1）。IP PDU通过在CCSDS封装数据包内逐个封装来传输。封装包直接在一个或多个CCSDS-SDLP传输帧内传输。该方法将CCSDS互联网协议扩展（IPE）约定与CCSDS AOS、TM或TC虚拟信道包（VCP）服务、TC多路复用器接入点包（MAPP）服务或Prox-1上的CCSDS封装服务结合使用。</p>
<p>CCSDS-IPE约定是将CCSDS-IPE八位字节预先分配给每个IP PDU，将结果封装在CCSDS封装包中（参见参考文献[3]），并在一个或多个CCSDS-SDLP帧内传输封装包（参见参考文献[4]-[7]和图2-1）。建议将此方法用于参考文献[8]中确定的所有IP PDU。</p>
<p>![截屏2022-07-15 上午10.11.44](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 上午10.11.44.png)</p>
<h2 id="2-2-服务概述"><a href="#2-2-服务概述" class="headerlink" title="2.2 服务概述"></a>2.2 服务概述</h2><p>![截屏2022-07-15 上午10.12.12](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 上午10.12.12.png)</p>
<p>图2-2描述了提供SDU的服务用户和执行跨空间链路传输PDU服务的服务提供商之间的接口。服务用户向服务提供商提供作为SDU的IP PDU及其相关IPE报头值（参考文献[8]中定义的值）及其相关数据链路层路由信息（即空间数据链路协议信道[SDLP\U信道]）。</p>
<h2 id="2-3功能概述"><a href="#2-3功能概述" class="headerlink" title="2.3功能概述"></a>2.3功能概述</h2><p>IPoC服务提供商的任务是生成IPE头并将其预先发送到发送端的IP PDU。在接收端，IPoC服务提供商提取IPE报头，并使用IPE值将IP PDU路由到适用的IP协议处理程序，以便在接收端进行传输。</p>
<p>##2.4IPE的概念和原理 </p>
<p>###2.4.1基本原理 </p>
<p>CCSDS IPE公约的主要目的是提供一种可互操作的方式，当CCSDS封装服务（参考文献[3]）被用于为IP提供数据链路层时，识别被封装的互联网协议。 IPE头使用一个和可选的一个以上的shim八位数来逻辑地扩展CCSDS封装包头。 参考文献[8]列出了CCSDS推荐的要封装的协议以及它们对IPE头内容的列举。</p>
<p>使用这个约定，封装服务为参考文献[8]中确定的IP协议提供了一个数据链路层。   IPE使用参考文献[3]中定义的封装服务基元和描述的服务。 通过IPE提供的额外服务是一种协议复用&#x2F;解复用能力。</p>
<p>IPE公约允许对IP中使用的子协议进行解复用。 它提供了一个独特的协议ID空间，不同于封装服务本身所使用的空间。 这就抽象化了，并允许分离最初由封装服务支持的协议和通过它进行的IP数据传输。    在与IPE公约相关的复用&#x2F;解复用层没有进行额外的处理。         多路复用&#x2F;解复用服务对它们所复用或解复用的协议的格式或约定一无所知。</p>
<p>注：IPE与封装服务的关系如图2-3所示。</p>
<p>![截屏2022-07-15 上午10.13.53](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 上午10.13.53.png)</p>
<h3 id="2-4-2-IPE头枚举和映射"><a href="#2-4-2-IPE头枚举和映射" class="headerlink" title="2.4.2 IPE头枚举和映射"></a>2.4.2 IPE头枚举和映射</h3><p>通常有许多IP数据类型需要封装。协议的确切数量取决于任务及其要求。这些协议在其他数据标准中有完整定义。因此，此处的目的是仅识别通常用于支持IP的辅助PDU格式。作为比较，路由器之间的串行链路通常携带16位点对点协议（PPP）字段，而以太网PDU携带16位以太网类型字段。在这些情况下，协议的枚举分别由互联网分配号码管理局（IANA）和电气与电子工程师协会（IEEE）定义。然后，包含枚举的表指向定义协议本身的标准。</p>
<p>另一种方法是封装传统链路层，例如多协议帧上中继，并使用其方法识别辅助PDU格式。</p>
<p>名义上在数据链路层识别的支持IP的辅助协议包括IPv4、IPv6、IP压缩头格式、多访问链路层的地址解析协议、链路层控制协议，包括链路度量交换和链路健康监测，各种数据链路和网络层配置协议，以及身份验证协议。</p>
<p>寻址和路由协议通常通过初始配置交换和链路状态向上&#x2F;向下信息连接到这些协议中。然而，应该注意的是，诸如开放最短路径优先（OSPF）、协议独立多播（PIM）和边界网关协议（BGP）等路由协议也通过网络层的问候交换或刷新来保持其自身的邻接或状态。</p>
<p>大多数协议都是围绕双向链路构建的，需要双向交换。由于在空间环境中，预计网络层协议必须能够使用单向链路，因此不建议需要这些协议。据信，如果涉及相当简单的网络，并且以透明的方式对其进行监控，则可以使用预先安排的静态设置而不是动态交换来验证和维护正确的配置。然而，如果适用于任务，则不禁止使用这些协议。</p>
<h1 id="3服务定义"><a href="#3服务定义" class="headerlink" title="3服务定义"></a>3服务定义</h1><h2 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h2><p>本节以原语的形式提供了服务定义，它提供了服务提供者和服务用户之间数据和控制信息逻辑交换的抽象模型。原语的定义独立于具体的实现方法。</p>
<p>当IPoC服务用于传输IP PDU时，那么</p>
<p>–IPoC服务SDU就是IP PDU；</p>
<p>–IPoC服务PDU是IPE标头+IP PDU。</p>
<p>原语的参数以抽象意义指定，并指定要提供给原语用户的信息。特定实现提供此信息的方式不受本规范的约束。除了本节中指定的参数外，实现还可以向服务用户提供其他参数（例如，用于控制服务、监测性能、促进诊断等的参数）。</p>
<h2 id="3-2原语摘要"><a href="#3-2原语摘要" class="headerlink" title="3.2原语摘要"></a>3.2原语摘要</h2><p>IPoC服务应使用以下原语：</p>
<p>–IPoC_Send。请求；</p>
<p>–IPoC_接收。指示</p>
<h2 id="3-3参数摘要"><a href="#3-3参数摘要" class="headerlink" title="3.3参数摘要"></a>3.3参数摘要</h2><h3 id="3-3-1UnitData参数是IPoC服务传输的SDU："><a href="#3-3-1UnitData参数是IPoC服务传输的SDU：" class="headerlink" title="3.3.1UnitData参数是IPoC服务传输的SDU："></a>3.3.1UnitData参数是IPoC服务传输的SDU：</h3><p>–它应包含一个分隔的、八位字节对齐的IP PDU；</p>
<p>–该服务容纳的IP PDU的最大长度应受到底层封装服务的最大SDU大小减去该服务使用的IPE报头大小的约束。</p>
<p>注：封装服务SDU的最大值由封装服务的最大数据单元长度管理参数给出（参考文献[3]第5节）。</p>
<h3 id="3-3-2IPE-Header-Value参数应包含参考文献-8-中规定的一个值。"><a href="#3-3-2IPE-Header-Value参数应包含参考文献-8-中规定的一个值。" class="headerlink" title="3.3.2IPE_Header_Value参数应包含参考文献[8]中规定的一个值。"></a>3.3.2IPE_Header_Value参数应包含参考文献[8]中规定的一个值。</h3><p>注意：IPE报头是对封装数据包报头的扩展，因为它有效地扩展了IP协议的数量，这些协议可以具有通过CCSDS空间数据链路传输的标准化定义。</p>
<p>###3.3.3SDLP_信道参数应识别底层CCSDS数据链路层服务的SAP:</p>
<p>-对于TM、TC或AOS的VCP服务封装：GVCID；</p>
<p>-对于TC的MAPP服务：GVCID和MAP ID；</p>
<p>-对于Prox-1：TFVN、SCID、端口ID、DFC_ID和物理通道ID（PCID）。</p>
<h2 id="3-4从底层子网假设的服务"><a href="#3-4从底层子网假设的服务" class="headerlink" title="3.4从底层子网假设的服务"></a>3.4从底层子网假设的服务</h2><h3 id="3-4-1概述"><a href="#3-4-1概述" class="headerlink" title="3.4.1概述"></a>3.4.1概述</h3><p>CCSDS封装服务（ENCAP）是专用的CCSDS服务，用于通过CCSDS空间链路传输IP PDU。表3-1描述了CCSDS推荐的AOS、TM、TC和Prox-1 SDLP上的IP传输服务。封装数据包是唯一推荐的用于封装IP PDU的CCSDS数据包类型。因此，数据包版本号（PVN）只能等于“封装数据包”，即二进制“111”。</p>
<p>![截屏2022-07-15 上午10.17.50](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 上午10.17.50.png)</p>
<h3 id="3-4-2CCSDS封装服务"><a href="#3-4-2CCSDS封装服务" class="headerlink" title="3.4.2CCSDS封装服务"></a>3.4.2CCSDS封装服务</h3><p>####3.4.2.1参考文献[3]中规定的CCSDS封装包应用于封装IPE报头和IP PDU，以便通过CCSDS空间数据链路传输。</p>
<h4 id="3-4-2-2一个CCSDS封装包应包含一个IPE头和一个IP-PDU。"><a href="#3-4-2-2一个CCSDS封装包应包含一个IPE头和一个IP-PDU。" class="headerlink" title="3.4.2.2一个CCSDS封装包应包含一个IPE头和一个IP PDU。"></a>3.4.2.2一个CCSDS封装包应包含一个IPE头和一个IP PDU。</h4><p>注意：由于封装数据包是CCSDS推荐的唯一携带IPE报头和IP PDU的数据包类型，并且是CCSDS推荐的唯一携带IP PDU的数据结构，因此封装数据包是CCSDS推荐的唯一用于传输IP PDU的数据包类型。</p>
<h4 id="3-4-2-3使用封装包携带IPE报头和IP-PDU没有限制。"><a href="#3-4-2-3使用封装包携带IPE报头和IP-PDU没有限制。" class="headerlink" title="3.4.2.3使用封装包携带IPE报头和IP PDU没有限制。"></a>3.4.2.3使用封装包携带IPE报头和IP PDU没有限制。</h4><h4 id="3-4-2-4只能使用CCSDS-AOS、TM、TC和Prox-1传输帧来承载包含IPE报头和IP-PDU的CCSDS封装包。"><a href="#3-4-2-4只能使用CCSDS-AOS、TM、TC和Prox-1传输帧来承载包含IPE报头和IP-PDU的CCSDS封装包。" class="headerlink" title="3.4.2.4只能使用CCSDS AOS、TM、TC和Prox-1传输帧来承载包含IPE报头和IP PDU的CCSDS封装包。"></a>3.4.2.4只能使用CCSDS AOS、TM、TC和Prox-1传输帧来承载包含IPE报头和IP PDU的CCSDS封装包。</h4><h4 id="3-4-2-5使用AOS、TM、TC或Prox-1传输帧来承载封装的IP-PDU没有限制。"><a href="#3-4-2-5使用AOS、TM、TC或Prox-1传输帧来承载封装的IP-PDU没有限制。" class="headerlink" title="3.4.2.5使用AOS、TM、TC或Prox-1传输帧来承载封装的IP PDU没有限制。"></a>3.4.2.5使用AOS、TM、TC或Prox-1传输帧来承载封装的IP PDU没有限制。</h4><h4 id="3-4-2-6对于通过CCSDS空间链路传输IP数据报，封装包协议ID应设置为IPE-ID的值，即“010”。"><a href="#3-4-2-6对于通过CCSDS空间链路传输IP数据报，封装包协议ID应设置为IPE-ID的值，即“010”。" class="headerlink" title="3.4.2.6对于通过CCSDS空间链路传输IP数据报，封装包协议ID应设置为IPE ID的值，即“010”。"></a>3.4.2.6对于通过CCSDS空间链路传输IP数据报，封装包协议ID应设置为IPE ID的值，即“010”。</h4><p>注：封装服务的协议ID空间（见参考文献[D2]）不同于IPE头协议ID空间（见参考文献[8]）。</p>
<h2 id="3-5IPOC服务原语"><a href="#3-5IPOC服务原语" class="headerlink" title="3.5IPOC服务原语"></a>3.5IPOC服务原语</h2><h4 id="3-5-1IPOC-u发送。请求"><a href="#3-5-1IPOC-u发送。请求" class="headerlink" title="3.5.1IPOC\u发送。请求"></a>3.5.1IPOC\u发送。请求</h4><h4 id="3-5-1-1-IPoC-发送的功能。用户IP实体应使用requestprimitive请求将IP-PDU交付给远程IP实体。"><a href="#3-5-1-1-IPoC-发送的功能。用户IP实体应使用requestprimitive请求将IP-PDU交付给远程IP实体。" class="headerlink" title="3.5.1.1 IPoC_发送的功能。用户IP实体应使用requestprimitive请求将IP PDU交付给远程IP实体。"></a>3.5.1.1 IPoC_发送的功能。用户IP实体应使用requestprimitive请求将IP PDU交付给远程IP实体。</h4><p>####3.5.1.2 原语</p>
<p>IPoC_Send.请求者应提供以下参数：IPoC_Send。请求（Unitdata、IPE\u Header\u值、SDLP\u通道）</p>
<p>####3.5.1.3生成。</p>
<p>IPoC_Send.Request由IPoC用户随时生成。</p>
<p>####3.5.1.4 收到的影响。</p>
<p>收到IPoC_发送。请求导致IPOC实体启动4.2中所述的程序。</p>
<p>####3.5.1.5其他意见</p>
<p>无。</p>
<h3 id="3-5-2IPOC-接收。指示"><a href="#3-5-2IPOC-接收。指示" class="headerlink" title="3.5.2IPOC_接收。指示"></a>3.5.2IPOC_接收。指示</h3><h4 id="3-5-2-1功能"><a href="#3-5-2-1功能" class="headerlink" title="3.5.2.1功能"></a>3.5.2.1功能</h4><p>IPoC_Receive.Indication原语应用于向用户互联网协议实体交付IP PDU。</p>
<h1 id="4协议定义"><a href="#4协议定义" class="headerlink" title="4协议定义"></a>4协议定义</h1><h2 id="4-1协议数据单元"><a href="#4-1协议数据单元" class="headerlink" title="4.1协议数据单元"></a>4.1协议数据单元</h2><h3 id="4-1-1要封装的IP-PDU应遵循IPE标题，没有间隙。"><a href="#4-1-1要封装的IP-PDU应遵循IPE标题，没有间隙。" class="headerlink" title="4.1.1要封装的IP PDU应遵循IPE标题，没有间隙。"></a>4.1.1要封装的IP PDU应遵循IPE标题，没有间隙。</h3><h3 id="4-1-2IPE头和IP-PDU的串联应为封装服务的数据单元参数（见参考文献-7-第3节）。"><a href="#4-1-2IPE头和IP-PDU的串联应为封装服务的数据单元参数（见参考文献-7-第3节）。" class="headerlink" title="4.1.2IPE头和IP PDU的串联应为封装服务的数据单元参数（见参考文献[7]第3节）。"></a>4.1.2IPE头和IP PDU的串联应为封装服务的数据单元参数（见参考文献[7]第3节）。</h3><p>注:</p>
<p>​	1封装数据包标头中的封装数据包长度字段由封装数据包标头、IPE标头和要封装的PDU的大小之和组成。</p>
<p>​	2 IPE标题的格式和位置如图4-1所示</p>
<p>![截屏2022-07-15 上午10.22.41](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-15 上午10.22.41.png)</p>
<h3 id="4-1-3-IPE头的长度应为八位字节的整数，最小长度为一个八位字节。"><a href="#4-1-3-IPE头的长度应为八位字节的整数，最小长度为一个八位字节。" class="headerlink" title="4.1.3 IPE头的长度应为八位字节的整数，最小长度为一个八位字节。"></a>4.1.3 IPE头的长度应为八位字节的整数，最小长度为一个八位字节。</h3><h3 id="4-1-4-IPE报头的位和八位字节顺序应遵循1-4-3中给出的约定。"><a href="#4-1-4-IPE报头的位和八位字节顺序应遵循1-4-3中给出的约定。" class="headerlink" title="4.1.4 IPE报头的位和八位字节顺序应遵循1.4.3中给出的约定。"></a>4.1.4 IPE报头的位和八位字节顺序应遵循1.4.3中给出的约定。</h3><h3 id="4-1-5-IPE报头应通过向第一个八位字节添加更重要的八位字节来扩展。通过将报头的每个八位字节的LSB（最终（最低有效）八位字节除外）设置为“0”，来表示一个或多个附加八位字节的使用；IPE集管的LSB应设置为“1”。"><a href="#4-1-5-IPE报头应通过向第一个八位字节添加更重要的八位字节来扩展。通过将报头的每个八位字节的LSB（最终（最低有效）八位字节除外）设置为“0”，来表示一个或多个附加八位字节的使用；IPE集管的LSB应设置为“1”。" class="headerlink" title="4.1.5 IPE报头应通过向第一个八位字节添加更重要的八位字节来扩展。通过将报头的每个八位字节的LSB（最终（最低有效）八位字节除外）设置为“0”，来表示一个或多个附加八位字节的使用；IPE集管的LSB应设置为“1”。"></a>4.1.5 IPE报头应通过向第一个八位字节添加更重要的八位字节来扩展。通过将报头的每个八位字节的LSB（最终（最低有效）八位字节除外）设置为“0”，来表示一个或多个附加八位字节的使用；IPE集管的LSB应设置为“1”。</h3><p>示例–对于两个八位字节头，IPE头值为33（十进制），最重要的八位字节将包含所有零。</p>
<h3 id="4-1-6根据1-4-3中给出的约定，IPE头应解释为无符号整数值。"><a href="#4-1-6根据1-4-3中给出的约定，IPE头应解释为无符号整数值。" class="headerlink" title="4.1.6根据1.4.3中给出的约定，IPE头应解释为无符号整数值。"></a>4.1.6根据1.4.3中给出的约定，IPE头应解释为无符号整数值。</h3><p>###4.1.7 IPE集管应包含参考[8]中给出的一个值。</p>
<h3 id="4-1-8-IPE标题值应为整个IPE标题内容的十进制值。"><a href="#4-1-8-IPE标题值应为整个IPE标题内容的十进制值。" class="headerlink" title="4.1.8 IPE标题值应为整个IPE标题内容的十进制值。"></a>4.1.8 IPE标题值应为整个IPE标题内容的十进制值。</h3><p>注意：</p>
<p>​	只有奇数IPE头值有效，因为最低有效八位字节的LSB必须具有值“1”。</p>
<p>​	如果IPE头由单个八位字节组成，则只有1到255之间的奇数IPE头值有效。</p>
<p>​	如果IPE头包含两个或多个八位字节，则</p>
<p>​		-1到255之间的奇数IPE头值有效；</p>
<p>​		-256到511之间没有有效的IPE标头值（因为第二个最低有效八位字节中的LSB值必须为“0”）；</p>
<p>​		-513到767之间的奇数IPE标题值有效；</p>
<p>​		-768到1023之间没有有效的IPE标头值（因为第二个最低有效八位字节中的LSB值必须为“0”）。</p>
<p>​	此模式在整个IPE头空间中继续。</p>
<h2 id="4-2发送端的协议程序"><a href="#4-2发送端的协议程序" class="headerlink" title="4.2发送端的协议程序"></a>4.2发送端的协议程序</h2><p>发送端的IPoC实体应：</p>
<p>–根据IPE\u Header\u Value参数的定义，构建与从用户接收的给定IP PDU相关的IPE头；</p>
<p>–将IPE头预先安装到IP PDU；</p>
<p>-将此结果作为SDU传递给封装服务。</p>
<p>##4.3接收端的协议程序</p>
<p>接收端的IPoC实体应：</p>
<p>–从封装服务接收SDU；</p>
<p>–提取并解码IPE头；</p>
<p>–将IP PDU交付给用户。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/15/IP%20Over%20CCSDS/" data-id="cl77bm6pq00072kfydjsgehxi" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SCPS-TP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/14/SCPS-TP/" class="article-date">
  <time class="dt-published" datetime="2022-07-14T12:18:08.091Z" itemprop="datePublished">2022-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>传输窗口，时间戳，压缩，拥塞提示</p>
<p>##2.Overview</p>
<p>SCPS-TP通过以下扩展解决了环境要求：</p>
<p>–TCP for Transactions（RFC 1644，参考文献[13]）</p>
<p>—减少启动TCP连接所需的握手，并提供“可靠数据报”操作来处理命令响应流量，对于需要在不等待连接握手的情况下开始数据传输的长延迟环境；</p>
<p>—窗口缩放（RFC 1323，参考文献[5]）</p>
<p>—解决了一次传输的数据可能超过65k个八位字节的通信环境往返时间测量（RFC 1323，参考文献[5]）</p>
<p>—解决具有高损耗、不断变化的延迟或一次性传输大量数据的环境防止包裹序列号（RFC 1323，参考文献[5]）</p>
<p>—解决非常长的延迟环境或非常高的带宽任务选择性否定确认（改编自RFC 1106，参考文献[B5]）</p>
<p>—解决高损耗环境选择性确认（RFC 2018，参考文献[15]）</p>
<p>—记录边界指示——为面向数据包的应用程序标记和可靠携带记录结束指示的能力</p>
<p>—尽力而为的通信—应用程序选择正确、有序但可能不完整的数据交付的能力</p>
<p>—报头压缩（改编自RFC 1144，参考[B6]）-解决低带宽环境</p>
<p>—低损耗拥塞控制或可选不使用拥塞控制</p>
<p>—显式拥塞通知（ECN）-可以在支持ICN的网络中提供改进的性能</p>
<p>—适用于空间环境的重传策略，以适应由于数据损坏、链路中断和拥塞而导致的丢失</p>
<h2 id="3-标准TCP的SCPS-TP扩展"><a href="#3-标准TCP的SCPS-TP扩展" class="headerlink" title="3.标准TCP的SCPS-TP扩展"></a>3.标准TCP的SCPS-TP扩展</h2><p>##3.1 SCPS-TP和TCP SCPS-TP之间的关系</p>
<p>采用互联网标准7（参考文献[4]）中规定的传输控制协议（TCP）及其支持RFC，以及本文件第3节中规定的修改和选项。</p>
<p>注：本文件第6节总结了在SCPS环境中实现TCP的要求。</p>
<p>###3.6 SCPS-TP头压缩</p>
<p>####3.6.1SCPS-TP压缩头格式</p>
<p>SCPS-TP压缩头应包含以下部分或全部字段：</p>
<p>注意：所有压缩头都需要包含以下为“强制”的字段；是否包含其他字段取决于未压缩的原TCP包头。</p>
<p>![截屏2022-07-14 下午7.59.33](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-14 下午7.59.33.png)</p>
<p>###3.6.2 SCPS-TP压缩头字段</p>
<p>####3.6.2.1 连接标识符</p>
<h5 id="3-6-2-1-1-连接标识符字段"><a href="#3-6-2-1-1-连接标识符字段" class="headerlink" title="3.6.2.1.1 连接标识符字段"></a>3.6.2.1.1 连接标识符字段</h5><p>对于所有SCPS-TP压缩头是必需的，并应占据压缩头的第一个八位字节。</p>
<h5 id="3-6-2-1-2-连接标识符字段应包含在SCPS功能选项的SYN段交换期间提供给对等方的连接标识符。"><a href="#3-6-2-1-2-连接标识符字段应包含在SCPS功能选项的SYN段交换期间提供给对等方的连接标识符。" class="headerlink" title="3.6.2.1.2 连接标识符字段应包含在SCPS功能选项的SYN段交换期间提供给对等方的连接标识符。"></a>3.6.2.1.2 连接标识符字段应包含在SCPS功能选项的SYN段交换期间提供给对等方的连接标识符。</h5><h4 id="3-6-2-2-压缩报头位向量"><a href="#3-6-2-2-压缩报头位向量" class="headerlink" title="3.6.2.2 压缩报头位向量"></a>3.6.2.2 压缩报头位向量</h4><h5 id="3-6-2-2-1-压缩报头位向量字段"><a href="#3-6-2-2-1-压缩报头位向量字段" class="headerlink" title="3.6.2.2.1 压缩报头位向量字段"></a>3.6.2.2.1 压缩报头位向量字段</h5><p>对于所有SCPS-TP压缩报头是必需的，并且应从连接标识符字段后的第一个八位开始，至少占用一个八位字节，但不得超过两个八位字节。</p>
<h5 id="3-6-2-2-2压缩报头位向量场应包含解压缩压缩报头所需的信息，详见表3-2。"><a href="#3-6-2-2-2压缩报头位向量场应包含解压缩压缩报头所需的信息，详见表3-2。" class="headerlink" title="3.6.2.2.2压缩报头位向量场应包含解压缩压缩报头所需的信息，详见表3-2。"></a>3.6.2.2.2压缩报头位向量场应包含解压缩压缩报头所需的信息，详见表3-2。</h5><p>![截屏2022-07-14 下午8.00.45](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-14 下午8.00.45.png)</p>
<h4 id="3-6-2-3紧急指针"><a href="#3-6-2-3紧急指针" class="headerlink" title="3.6.2.3紧急指针"></a>3.6.2.3紧急指针</h4><h5 id="3-6-2-3-1如果URG标志在TCP标头中设置为“1”，则应包括紧急指针字段，并应占据压缩标头位向量字段后的两个八位字节。"><a href="#3-6-2-3-1如果URG标志在TCP标头中设置为“1”，则应包括紧急指针字段，并应占据压缩标头位向量字段后的两个八位字节。" class="headerlink" title="3.6.2.3.1如果URG标志在TCP标头中设置为“1”，则应包括紧急指针字段，并应占据压缩标头位向量字段后的两个八位字节。"></a>3.6.2.3.1如果URG标志在TCP标头中设置为“1”，则应包括紧急指针字段，并应占据压缩标头位向量字段后的两个八位字节。</h5><h5 id="3-6-2-3-2紧急指针字段应包含TCP标头中未修改的紧急指针值。"><a href="#3-6-2-3-2紧急指针字段应包含TCP标头中未修改的紧急指针值。" class="headerlink" title="3.6.2.3.2紧急指针字段应包含TCP标头中未修改的紧急指针值。"></a>3.6.2.3.2紧急指针字段应包含TCP标头中未修改的紧急指针值。</h5><h4 id="3-6-2-4窗口"><a href="#3-6-2-4窗口" class="headerlink" title="3.6.2.4窗口"></a>3.6.2.4窗口</h4><h5 id="3-6-2-4-1如果确认号的窗口值与连接上发送的最后一段相比发生了变化，或者与连接上发送的最后一段相比没有任何变化，则应包括窗口字段，并应占据紧急指针字段位置后的两个八位字节。"><a href="#3-6-2-4-1如果确认号的窗口值与连接上发送的最后一段相比发生了变化，或者与连接上发送的最后一段相比没有任何变化，则应包括窗口字段，并应占据紧急指针字段位置后的两个八位字节。" class="headerlink" title="3.6.2.4.1如果确认号的窗口值与连接上发送的最后一段相比发生了变化，或者与连接上发送的最后一段相比没有任何变化，则应包括窗口字段，并应占据紧急指针字段位置后的两个八位字节。"></a>3.6.2.4.1如果确认号的窗口值与连接上发送的最后一段相比发生了变化，或者与连接上发送的最后一段相比没有任何变化，则应包括窗口字段，并应占据紧急指针字段位置后的两个八位字节。</h5><h5 id="3-6-2-4-2窗口字段应包含TCP标头中未修改的窗口值。"><a href="#3-6-2-4-2窗口字段应包含TCP标头中未修改的窗口值。" class="headerlink" title="3.6.2.4.2窗口字段应包含TCP标头中未修改的窗口值。"></a>3.6.2.4.2窗口字段应包含TCP标头中未修改的窗口值。</h5><h4 id="3-6-2-5确认号"><a href="#3-6-2-5确认号" class="headerlink" title="3.6.2.5确认号"></a>3.6.2.5确认号</h4><h5 id="3-6-2-5-1如果确认号的窗口值与连接上发送的最后一段相比发生了变化，或者与连接上发送的最后一段相比没有任何变化，则应包括确认号字段，并应占据紧跟在窗口字段之后的四个八位字节。"><a href="#3-6-2-5-1如果确认号的窗口值与连接上发送的最后一段相比发生了变化，或者与连接上发送的最后一段相比没有任何变化，则应包括确认号字段，并应占据紧跟在窗口字段之后的四个八位字节。" class="headerlink" title="3.6.2.5.1如果确认号的窗口值与连接上发送的最后一段相比发生了变化，或者与连接上发送的最后一段相比没有任何变化，则应包括确认号字段，并应占据紧跟在窗口字段之后的四个八位字节。"></a>3.6.2.5.1如果确认号的窗口值与连接上发送的最后一段相比发生了变化，或者与连接上发送的最后一段相比没有任何变化，则应包括确认号字段，并应占据紧跟在窗口字段之后的四个八位字节。</h5><h5 id="3-6-2-5-2确认号字段应包含来自TCP头的未修改确认号。"><a href="#3-6-2-5-2确认号字段应包含来自TCP头的未修改确认号。" class="headerlink" title="3.6.2.5.2确认号字段应包含来自TCP头的未修改确认号。"></a>3.6.2.5.2确认号字段应包含来自TCP头的未修改确认号。</h5><h4 id="3-6-2-6序列号"><a href="#3-6-2-6序列号" class="headerlink" title="3.6.2.6序列号"></a>3.6.2.6序列号</h4><h5 id="3-6-2-6-1如果段可重新传输（即，包括用户数据或FIN标志设置为“1”），则应包括序列号字段，并应占据ACK号字段位置后的四个八位字节。"><a href="#3-6-2-6-1如果段可重新传输（即，包括用户数据或FIN标志设置为“1”），则应包括序列号字段，并应占据ACK号字段位置后的四个八位字节。" class="headerlink" title="3.6.2.6.1如果段可重新传输（即，包括用户数据或FIN标志设置为“1”），则应包括序列号字段，并应占据ACK号字段位置后的四个八位字节。"></a>3.6.2.6.1如果段可重新传输（即，包括用户数据或FIN标志设置为“1”），则应包括序列号字段，并应占据ACK号字段位置后的四个八位字节。</h5><h5 id="3-6-2-6-2序列号字段应包含TCP标头中未修改的序列号。"><a href="#3-6-2-6-2序列号字段应包含TCP标头中未修改的序列号。" class="headerlink" title="3.6.2.6.2序列号字段应包含TCP标头中未修改的序列号。"></a>3.6.2.6.2序列号字段应包含TCP标头中未修改的序列号。</h5><h4 id="3-6-2-7压缩短格式SNACK选项"><a href="#3-6-2-7压缩短格式SNACK选项" class="headerlink" title="3.6.2.7压缩短格式SNACK选项"></a>3.6.2.7压缩短格式SNACK选项</h4><h5 id="3-6-2-7-1只要存在压缩短格式（即不包括SNACK位向量）SNACK选项，就应设置压缩短格式SNACK位。压缩短格式SNACK选项应占据序列号字段后面的四个八位字节。"><a href="#3-6-2-7-1只要存在压缩短格式（即不包括SNACK位向量）SNACK选项，就应设置压缩短格式SNACK位。压缩短格式SNACK选项应占据序列号字段后面的四个八位字节。" class="headerlink" title="3.6.2.7.1只要存在压缩短格式（即不包括SNACK位向量）SNACK选项，就应设置压缩短格式SNACK位。压缩短格式SNACK选项应占据序列号字段后面的四个八位字节。"></a>3.6.2.7.1只要存在压缩短格式（即不包括SNACK位向量）SNACK选项，就应设置压缩短格式SNACK位。压缩短格式SNACK选项应占据序列号字段后面的四个八位字节。</h5><h5 id="3-6-2-7-2压缩短格式SNACK选项的前两个八位字节应包含孔1偏移（见3-5-2-3）。接下来的两个八位字节应包含孔1长度（见3-5-2-4）。注意：其他SNACK选项，包括其他短格式和所有长格式选项（未压缩选项长度大于六个八位字节的选项）必须在压缩头的未压缩TCP选项部分中携带。"><a href="#3-6-2-7-2压缩短格式SNACK选项的前两个八位字节应包含孔1偏移（见3-5-2-3）。接下来的两个八位字节应包含孔1长度（见3-5-2-4）。注意：其他SNACK选项，包括其他短格式和所有长格式选项（未压缩选项长度大于六个八位字节的选项）必须在压缩头的未压缩TCP选项部分中携带。" class="headerlink" title="3.6.2.7.2压缩短格式SNACK选项的前两个八位字节应包含孔1偏移（见3.5.2.3）。接下来的两个八位字节应包含孔1长度（见3.5.2.4）。注意：其他SNACK选项，包括其他短格式和所有长格式选项（未压缩选项长度大于六个八位字节的选项）必须在压缩头的未压缩TCP选项部分中携带。"></a>3.6.2.7.2压缩短格式SNACK选项的前两个八位字节应包含孔1偏移（见3.5.2.3）。接下来的两个八位字节应包含孔1长度（见3.5.2.4）。注意：其他SNACK选项，包括其他短格式和所有长格式选项（未压缩选项长度大于六个八位字节的选项）必须在压缩头的未压缩TCP选项部分中携带。</h5><h4 id="3-6-2-8超时时间戳"><a href="#3-6-2-8超时时间戳" class="headerlink" title="3.6.2.8超时时间戳"></a>3.6.2.8超时时间戳</h4><h5 id="3-6-2-8-1如果出现以下情况，则应包括出站时间戳（TS1）字段："><a href="#3-6-2-8-1如果出现以下情况，则应包括出站时间戳（TS1）字段：" class="headerlink" title="3.6.2.8.1如果出现以下情况，则应包括出站时间戳（TS1）字段："></a>3.6.2.8.1如果出现以下情况，则应包括出站时间戳（TS1）字段：</h5><p>–存在TCP时间戳选项；和</p>
<p>–SCPS能力选项协商表明NL Ts不可用；</p>
<p>并应占据SequenceNumber字段位置后的一个或多个八位字节。</p>
<p>#####3.6.2.8.2TS1字段应包含要回显的时间戳值。</p>
<h4 id="3-6-2-9ECHO回复时间戳"><a href="#3-6-2-9ECHO回复时间戳" class="headerlink" title="3.6.2.9ECHO回复时间戳"></a>3.6.2.9ECHO回复时间戳</h4><h5 id="3-6-2-9-1如果存在TCP时间戳选项，则应包括ECHO回复时间戳（TS2）字段，并应占据TS1字段位置后的一个或多个八位字节。"><a href="#3-6-2-9-1如果存在TCP时间戳选项，则应包括ECHO回复时间戳（TS2）字段，并应占据TS1字段位置后的一个或多个八位字节。" class="headerlink" title="3.6.2.9.1如果存在TCP时间戳选项，则应包括ECHO回复时间戳（TS2）字段，并应占据TS1字段位置后的一个或多个八位字节。"></a>3.6.2.9.1如果存在TCP时间戳选项，则应包括ECHO回复时间戳（TS2）字段，并应占据TS1字段位置后的一个或多个八位字节。</h5><h5 id="3-6-2-9-2TS2字段应包含ECHO回复时间戳值。注：由于在压缩的报头位向量中使用了单独的“TS1”和“TS2”位，因此如果需要，可以压缩RFC-1072（参考-B4-）时间戳的等效值。"><a href="#3-6-2-9-2TS2字段应包含ECHO回复时间戳值。注：由于在压缩的报头位向量中使用了单独的“TS1”和“TS2”位，因此如果需要，可以压缩RFC-1072（参考-B4-）时间戳的等效值。" class="headerlink" title="3.6.2.9.2TS2字段应包含ECHO回复时间戳值。注：由于在压缩的报头位向量中使用了单独的“TS1”和“TS2”位，因此如果需要，可以压缩RFC 1072（参考[B4]）时间戳的等效值。"></a>3.6.2.9.2TS2字段应包含ECHO回复时间戳值。注：由于在压缩的报头位向量中使用了单独的“TS1”和“TS2”位，因此如果需要，可以压缩RFC 1072（参考[B4]）时间戳的等效值。</h5><h4 id="3-6-2-10TCP选项长度"><a href="#3-6-2-10TCP选项长度" class="headerlink" title="3.6.2.10TCP选项长度"></a>3.6.2.10TCP选项长度</h4><h5 id="3-6-2-10-1如果任何TCP选项在标头压缩后仍然存在，则应包括TCP选项长度字段，并应在TS2字段位置后立即占据一个八位字节。"><a href="#3-6-2-10-1如果任何TCP选项在标头压缩后仍然存在，则应包括TCP选项长度字段，并应在TS2字段位置后立即占据一个八位字节。" class="headerlink" title="3.6.2.10.1如果任何TCP选项在标头压缩后仍然存在，则应包括TCP选项长度字段，并应在TS2字段位置后立即占据一个八位字节。"></a>3.6.2.10.1如果任何TCP选项在标头压缩后仍然存在，则应包括TCP选项长度字段，并应在TS2字段位置后立即占据一个八位字节。</h5><h5 id="3-6-2-10-2TCP选项长度字段应包含剩余TCP选项的长度（以八位字节为单位）。注意–压缩头位向量字段中的记录边界标志、TS1和TS2标志以及SNACK标志用于压缩TCP选项。"><a href="#3-6-2-10-2TCP选项长度字段应包含剩余TCP选项的长度（以八位字节为单位）。注意–压缩头位向量字段中的记录边界标志、TS1和TS2标志以及SNACK标志用于压缩TCP选项。" class="headerlink" title="3.6.2.10.2TCP选项长度字段应包含剩余TCP选项的长度（以八位字节为单位）。注意–压缩头位向量字段中的记录边界标志、TS1和TS2标志以及SNACK标志用于压缩TCP选项。"></a>3.6.2.10.2TCP选项长度字段应包含剩余TCP选项的长度（以八位字节为单位）。注意–压缩头位向量字段中的记录边界标志、TS1和TS2标志以及SNACK标志用于压缩TCP选项。</h5><h4 id="3-6-2-11TCP选项"><a href="#3-6-2-11TCP选项" class="headerlink" title="3.6.2.11TCP选项"></a>3.6.2.11TCP选项</h4><h4 id="3-6-2-11-1如果任何TCP选项在标头压缩后仍然存在，则应包括TCP选项字段，并应立即占用TCP选项长度字段后的一个或多个八位字节。"><a href="#3-6-2-11-1如果任何TCP选项在标头压缩后仍然存在，则应包括TCP选项字段，并应立即占用TCP选项长度字段后的一个或多个八位字节。" class="headerlink" title="3.6.2.11.1如果任何TCP选项在标头压缩后仍然存在，则应包括TCP选项字段，并应立即占用TCP选项长度字段后的一个或多个八位字节。"></a>3.6.2.11.1如果任何TCP选项在标头压缩后仍然存在，则应包括TCP选项字段，并应立即占用TCP选项长度字段后的一个或多个八位字节。</h4><h5 id="3-6-2-11-2TCP选项字段应包含任何未压缩的TCP选项。"><a href="#3-6-2-11-2TCP选项字段应包含任何未压缩的TCP选项。" class="headerlink" title="3.6.2.11.2TCP选项字段应包含任何未压缩的TCP选项。"></a>3.6.2.11.2TCP选项字段应包含任何未压缩的TCP选项。</h5><p>####3.6.2.12Pad </p>
<p>#####3.6.2.12.1PAD字段可包括在内，以确保压缩头在均匀八位字节边界上结束，并应在TCP选项字段位置后立即占据一个八位字节。</p>
<p>#####3.6.2.12.2如果包括，焊盘字段的值应为零。</p>
<p>#####3.6.2.12.3A如果Pad字段的包含需要向单个八位压缩头比特向量字段添加第二个八位字节，则不应包括Pad字段。</p>
<p>注意–压缩报头位向量场的零值第二个八位组也可用于将压缩报头填充到偶数八位组边界。</p>
<h4 id="3-6-2-13校验和"><a href="#3-6-2-13校验和" class="headerlink" title="3.6.2.13校验和"></a>3.6.2.13校验和</h4><h5 id="3-6-2-13-1校验和字段对于所有SCPS-TP压缩头是必需的，并应占据压缩头的最后两个八位字节。"><a href="#3-6-2-13-1校验和字段对于所有SCPS-TP压缩头是必需的，并应占据压缩头的最后两个八位字节。" class="headerlink" title="3.6.2.13.1校验和字段对于所有SCPS-TP压缩头是必需的，并应占据压缩头的最后两个八位字节。"></a>3.6.2.13.1校验和字段对于所有SCPS-TP压缩头是必需的，并应占据压缩头的最后两个八位字节。</h5><h5 id="3-6-2-13-2校验和字段应包含使用标准TCP校验和算法根据压缩头、用户数据和TCP伪头内容获得的值。当使用报头压缩时，计算校验和时，十进制值105（压缩的SCPS-TP）应用作伪报头中的N用户互联网协议号。"><a href="#3-6-2-13-2校验和字段应包含使用标准TCP校验和算法根据压缩头、用户数据和TCP伪头内容获得的值。当使用报头压缩时，计算校验和时，十进制值105（压缩的SCPS-TP）应用作伪报头中的N用户互联网协议号。" class="headerlink" title="3.6.2.13.2校验和字段应包含使用标准TCP校验和算法根据压缩头、用户数据和TCP伪头内容获得的值。当使用报头压缩时，计算校验和时，十进制值105（压缩的SCPS-TP）应用作伪报头中的N用户互联网协议号。"></a>3.6.2.13.2校验和字段应包含使用标准TCP校验和算法根据压缩头、用户数据和TCP伪头内容获得的值。当使用报头压缩时，计算校验和时，十进制值105（压缩的SCPS-TP）应用作伪报头中的N用户互联网协议号。</h5><p>注：SCPS-TP压缩段格式如图3-10所示。仅在必要时才包括用虚线轮廓显示的字段（在压缩头位向量的第一个八位组之后但在校验和之前）。它们的存在或不存在由压缩头比特向量中的相应比特表示。在图中，每个可选字段显示了三个信息元素：表示其存在的压缩头位向量的位、字段名称和字段长度（以八位字节为单位）。它们以“位：名称（长度）”的格式显示。</p>
<p>![截屏2022-07-14 下午8.03.47](&#x2F;Users&#x2F;sunzekun&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-07-14 下午8.03.47.png)</p>
<h3 id="3-6-3SCPS-TP压缩报头调用"><a href="#3-6-3SCPS-TP压缩报头调用" class="headerlink" title="3.6.3SCPS-TP压缩报头调用"></a>3.6.3SCPS-TP压缩报头调用</h3><h4 id="3-6-3-1TCP启动连接时，应通过在其未压缩的SYN段中包含SCPS能力选项（Com位设置为“1”）来请求SCPS-TP报头压缩。"><a href="#3-6-3-1TCP启动连接时，应通过在其未压缩的SYN段中包含SCPS能力选项（Com位设置为“1”）来请求SCPS-TP报头压缩。" class="headerlink" title="3.6.3.1TCP启动连接时，应通过在其未压缩的SYN段中包含SCPS能力选项（Com位设置为“1”）来请求SCPS-TP报头压缩。"></a>3.6.3.1TCP启动连接时，应通过在其未压缩的SYN段中包含SCPS能力选项（Com位设置为“1”）来请求SCPS-TP报头压缩。</h4><h4 id="3-6-3-2响应TCP端点应a）通过在其SYN-ACK段中将Com位设置为“1”的情况下包括其自身的SCPS功能选项，接受执行SCPS报头压缩的提议；b）-拒绝执行SCPS标头压缩的提议。注1有关SCPS功能选项的详细讨论，请参阅3-2-3。2-SCPS报头压缩算法支持对数据承载段（如在未压缩的TCP中）的确认进行“背负”，但是否行使此功能是一种实现选项。特定实现的压缩器可以与数据分开发送确认（以及与正在传输的数据不直接相关的其他信息），以确保数据承载段的报头大小恒定。（这有助于在传输批量数据时打包固定长度的下层帧。）根据RFC-1122（参考文献-2-）和TCP中规定的稳健性原则，解压缩器必须准备好接受背负式确认，即使该实现中的解压缩器没有生成它们。（稳健性原则大致规定“接受时要慷慨，发送时要保守”，旨在促进互操作性。）3当使用SCPS-NP时，传输协议标识符（TP-ID）6标识未压缩的TCP，TP-ID-5标识压缩段。如果不使用SCPS-NP，则存在区分这些数据包类型的替代方法；例如，可以分配两个CCSDS路径id来区分压缩段和未压缩段。有关SCPS-NP传输协议标识符的完整描述，请参阅SCPS-NP规范（参考文献-10-）。"><a href="#3-6-3-2响应TCP端点应a）通过在其SYN-ACK段中将Com位设置为“1”的情况下包括其自身的SCPS功能选项，接受执行SCPS报头压缩的提议；b）-拒绝执行SCPS标头压缩的提议。注1有关SCPS功能选项的详细讨论，请参阅3-2-3。2-SCPS报头压缩算法支持对数据承载段（如在未压缩的TCP中）的确认进行“背负”，但是否行使此功能是一种实现选项。特定实现的压缩器可以与数据分开发送确认（以及与正在传输的数据不直接相关的其他信息），以确保数据承载段的报头大小恒定。（这有助于在传输批量数据时打包固定长度的下层帧。）根据RFC-1122（参考文献-2-）和TCP中规定的稳健性原则，解压缩器必须准备好接受背负式确认，即使该实现中的解压缩器没有生成它们。（稳健性原则大致规定“接受时要慷慨，发送时要保守”，旨在促进互操作性。）3当使用SCPS-NP时，传输协议标识符（TP-ID）6标识未压缩的TCP，TP-ID-5标识压缩段。如果不使用SCPS-NP，则存在区分这些数据包类型的替代方法；例如，可以分配两个CCSDS路径id来区分压缩段和未压缩段。有关SCPS-NP传输协议标识符的完整描述，请参阅SCPS-NP规范（参考文献-10-）。" class="headerlink" title="3.6.3.2响应TCP端点应a）通过在其SYN ACK段中将Com位设置为“1”的情况下包括其自身的SCPS功能选项，接受执行SCPS报头压缩的提议；b） 拒绝执行SCPS标头压缩的提议。注1有关SCPS功能选项的详细讨论，请参阅3.2.3。2 SCPS报头压缩算法支持对数据承载段（如在未压缩的TCP中）的确认进行“背负”，但是否行使此功能是一种实现选项。特定实现的压缩器可以与数据分开发送确认（以及与正在传输的数据不直接相关的其他信息），以确保数据承载段的报头大小恒定。（这有助于在传输批量数据时打包固定长度的下层帧。）根据RFC 1122（参考文献[2]）和TCP中规定的稳健性原则，解压缩器必须准备好接受背负式确认，即使该实现中的解压缩器没有生成它们。（稳健性原则大致规定“接受时要慷慨，发送时要保守”，旨在促进互操作性。）3当使用SCPS-NP时，传输协议标识符（TP-ID）6标识未压缩的TCP，TP-ID 5标识压缩段。如果不使用SCPS-NP，则存在区分这些数据包类型的替代方法；例如，可以分配两个CCSDS路径id来区分压缩段和未压缩段。有关SCPS-NP传输协议标识符的完整描述，请参阅SCPS-NP规范（参考文献[10]）。"></a>3.6.3.2响应TCP端点应a）通过在其SYN ACK段中将Com位设置为“1”的情况下包括其自身的SCPS功能选项，接受执行SCPS报头压缩的提议；b） 拒绝执行SCPS标头压缩的提议。注1有关SCPS功能选项的详细讨论，请参阅3.2.3。2 SCPS报头压缩算法支持对数据承载段（如在未压缩的TCP中）的确认进行“背负”，但是否行使此功能是一种实现选项。特定实现的压缩器可以与数据分开发送确认（以及与正在传输的数据不直接相关的其他信息），以确保数据承载段的报头大小恒定。（这有助于在传输批量数据时打包固定长度的下层帧。）根据RFC 1122（参考文献[2]）和TCP中规定的稳健性原则，解压缩器必须准备好接受背负式确认，即使该实现中的解压缩器没有生成它们。（稳健性原则大致规定“接受时要慷慨，发送时要保守”，旨在促进互操作性。）3当使用SCPS-NP时，传输协议标识符（TP-ID）6标识未压缩的TCP，TP-ID 5标识压缩段。如果不使用SCPS-NP，则存在区分这些数据包类型的替代方法；例如，可以分配两个CCSDS路径id来区分压缩段和未压缩段。有关SCPS-NP传输协议标识符的完整描述，请参阅SCPS-NP规范（参考文献[10]）。</h4><p>###3.6.4从网络层接收到“压缩TCP”类型段以及相关网络层信息（如数据包长度、传入源时间戳）后的解压缩处理，以及源地址和目标地址：</p>
<p>a）解压缩程序应使用连接标识符和网络地址来查找该数据包应与之关联的TCP端点；</p>
<p>b） 如果未定位端点，解压缩器应丢弃该段并记录错误；</p>
<p>c） 如果端点位于，解压缩器应使用来自TCP伪报头的信息来验证压缩段中的校验和；</p>
<p>d） 如果校验和失败，解压缩程序应丢弃该段并记录错误；</p>
<p>e） 解压缩器应使用从连接上接收的前一段未压缩标头创建的模板重建TCP标头，所有字段（初始化为零的端口信息除外）；</p>
<p>f） 解压缩器应保存重建的报头，以用于解压缩后续压缩数据包；</p>
<p>g） 解压缩器应输出解压缩段，以便通过TCP立即处理或插入无序队列。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/14/SCPS-TP/" data-id="cl77bm6po00042kfy4tdndhs2" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/07/25/SDN_Final/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/24/SDN/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/18/%E7%AE%80%E5%86%99/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/17/%E7%BA%BF%E6%80%A7%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>