<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="#0.文件说明 input.py:输入的参数 Linklist.py:定义的数据结构，如流的曲线、流的参数等 SatTopo_update.py:定义了在main函数中需要用到的函数，找路、映射流、判断是否能映射等 main.py:主函数，运行主函数，将进行一个默认2000条流，每条流找5条路径进行传输的映射。 #1.流程 1234567891011graph TBA[\读取txt\]--&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/06/07/%E9%80%89%E8%B7%AF/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#0.文件说明 input.py:输入的参数 Linklist.py:定义的数据结构，如流的曲线、流的参数等 SatTopo_update.py:定义了在main函数中需要用到的函数，找路、映射流、判断是否能映射等 main.py:主函数，运行主函数，将进行一个默认2000条流，每条流找5条路径进行传输的映射。 #1.流程 1234567891011graph TBA[\读取txt\]--&gt;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h4he3u7dxlj21g30u07bz.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h4he3xttlqj21h90u07fd.jpg">
<meta property="article:published_time" content="2022-06-07T07:55:21.764Z">
<meta property="article:modified_time" content="2022-07-24T05:35:49.257Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h4he3u7dxlj21g30u07bz.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-选路" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/07/%E9%80%89%E8%B7%AF/" class="article-date">
  <time class="dt-published" datetime="2022-06-07T07:55:21.764Z" itemprop="datePublished">2022-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#0.文件说明</p>
<p>input.py:输入的参数</p>
<p>Linklist.py:定义的数据结构，如流的曲线、流的参数等</p>
<p>SatTopo_update.py:定义了在main函数中需要用到的函数，找路、映射流、判断是否能映射等</p>
<p>main.py:主函数，运行主函数，将进行一个默认2000条流，每条流找5条路径进行传输的映射。</p>
<p>#1.流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[\读取txt\]--&gt;B(得到拓扑)</span><br><span class="line">B--&gt;C&#123;选中传输流&#125;</span><br><span class="line">C--&gt;K(获取符合条件的拓扑)</span><br><span class="line">K--&gt;D(获取K条路径)</span><br><span class="line">D--Yes--&gt;G(采取路径传输flow)</span><br><span class="line">D--No--&gt;C</span><br><span class="line">G--&gt;H&#123;判断符合需求&#125;</span><br><span class="line">H--Yes--&gt;I(放入路径集)</span><br><span class="line">I--&gt;J(选择开销最小路径来传输)</span><br><span class="line">J--&gt;C</span><br></pre></td></tr></table></figure>

<p>#2.判断路径是否符合要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[\输入拓扑and路径and流\]--&gt;B(复制拓扑and初始化函数内参数)</span><br><span class="line">B--&gt;D(将流根据路径映射进拓扑中,并更新网络拓扑)</span><br><span class="line">D--&gt;E(根据更新后的拓扑的到达曲线,沿路径逐跳更新带宽和缓存,并判断是否符合带宽and缓存要求)</span><br><span class="line">E--&gt;F(根据获得的链路到达曲线计算出开销)</span><br><span class="line">F--&gt;G[\返回结果\]</span><br></pre></td></tr></table></figure>

<p>##2.1更新网络拓扑</p>
<p>###2.1.1获得每个链路的到达曲线</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历每个上游链路，1.将某一上游链路流入到此链路的流求和，2.计算收到物理限制的求和流，3.遍历另一个上游链路，跳回步骤1</span></span><br><span class="line"><span class="comment"># 以上操作在computeAllInFlow函数中实现</span></span><br><span class="line">tempInCurve = computeAllInFlow(topo, this_node, class_node, nxt_node)</span><br></pre></td></tr></table></figure>

<p>###2.1.2将已经映射到拓扑中的链路保存在链路的进入曲线In_Curve中,包含信息：此流的上游链路、此流的下游链路、流信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tempInFlow = &#123;<span class="string">&#x27;priNode&#x27;</span>: pre_class_node, <span class="string">&#x27;thisNode&#x27;</span>: this_node,</span><br><span class="line">            <span class="string">&#x27;classNode&#x27;</span>: class_node, <span class="string">&#x27;nxtNode&#x27;</span>: nxt_node, <span class="string">&#x27;flow&#x27;</span>: tempFlow&#125;</span><br><span class="line">topo[class_node][nxt_node][<span class="string">&#x27;In_Curve&#x27;</span>].insert(tempInFlow, topo[class_node][nxt_node][<span class="string">&#x27;In_Curve&#x27;</span>].size)</span><br></pre></td></tr></table></figure>

<p>####1）其中tempFlow保存着映射流flowInCurve的斜率和缓存消息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempFlow.insert(&#123;<span class="string">&#x27;r&#x27;</span>: flow_selected[<span class="string">&#x27;r&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;b&#x27;</span>: flowInCurve.subs(<span class="number">0</span>)&#125;, tempFlow.size)</span><br></pre></td></tr></table></figure>

<p>####2）flowInCurve初始化为输入流的斜率r与截距b</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputFlowCurve = curveInterval(flow_selected[<span class="string">&#x27;r&#x27;</span>], flow_selected[<span class="string">&#x27;b&#x27;</span>], <span class="number">0</span>, max_time)</span><br><span class="line">flowInCurve = curveFull()</span><br><span class="line">flowInCurve.addAnotherCurveOneInterval(inputFlowCurve)</span><br></pre></td></tr></table></figure>

<p>####3）之后每经过一跳，会根据CBS服务时间增大截距b（突发）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowInCurve.addBAll(compute_nodes_T_buffer</span><br><span class="line">                      (flowInCurve, topo[this_node][class_node][<span class="string">&#x27;T&#x27;</span>])-flowInCurve.subs(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>在映射流到路径中的下一链路时，则将更新后的flowInCurve映射进入</p>
<h3 id="2-1-3更新网络拓扑"><a href="#2-1-3更新网络拓扑" class="headerlink" title="2.1.3更新网络拓扑"></a>2.1.3更新网络拓扑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上游链路受到物理限制的输出曲线之和便是此链路的到达曲线，更新进网络拓扑topo[class_node][nxt_node][&#x27;Out_Curve&#x27;]中</span></span><br><span class="line">topo[class_node][nxt_node][<span class="string">&#x27;Out_Curve&#x27;</span>] = tempInCurve</span><br></pre></td></tr></table></figure>

<p>其中tempInCurve由2.1.1小节获得</p>
<h2 id="2-2其余工作"><a href="#2-2其余工作" class="headerlink" title="2.2其余工作"></a>2.2其余工作</h2><p>###1）造轮子，如记录曲线的数据结构curveFull、只记录流特征值（斜率和截距or突发）的数据结构flows、记录流映射（从所有上游链路映射到此链路的流与流的属性）的数据结构inFlow，省略介绍。</p>
<p>###2）计算缓存、判断是否符合需求、计算开销等，省略介绍。</p>
<h1 id="3-使用说明"><a href="#3-使用说明" class="headerlink" title="3.使用说明"></a>3.使用说明</h1><p>##3.1 input文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mbit unit</span></span><br><span class="line">Mbit = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CBS metrics</span></span><br><span class="line">L_ij_E = <span class="number">0.012</span> * Mbit  <span class="comment"># packet length 1.5KB</span></span><br><span class="line">L_ij_A = <span class="number">0.012</span> * Mbit</span><br><span class="line">L_ij_B = <span class="number">0.012</span> * Mbit</span><br><span class="line">_L_ij_A = <span class="number">0.012</span> * Mbit  <span class="comment"># maximum packet length 1.5KB</span></span><br><span class="line">max_packet_length = <span class="number">0.012</span> * Mbit</span><br><span class="line">b_ij = <span class="number">0.012</span> * Mbit  <span class="comment"># flow`s buffer</span></span><br><span class="line">I_ij_A = <span class="number">240</span> * Mbit  <span class="comment"># CBS Idleslope for class A 30MB</span></span><br><span class="line">I_ij_B = <span class="number">60</span> * Mbit  <span class="comment"># CBS Idleslope for class B 7.5MB</span></span><br><span class="line">S_ij_A = -<span class="number">1360</span> * Mbit  <span class="comment"># CBS Sendslope for class A 170MB</span></span><br><span class="line">S_ij_B = -<span class="number">1540</span> * Mbit  <span class="comment"># CBS Sendslope for class B 192.5MB</span></span><br><span class="line">c_ij = <span class="number">1600</span> * Mbit  <span class="comment"># physical rate 200MB</span></span><br><span class="line">r_ij = <span class="number">80</span> * Mbit  <span class="comment"># CDT rate 10MB</span></span><br><span class="line">R_ij_A = I_ij_A * (c_ij - r_ij) / (I_ij_A - S_ij_A)</span><br><span class="line">T_ij_A = <span class="number">1</span> / (c_ij - r_ij) * (_L_ij_A + b_ij + r_ij * _L_ij_A / c_ij)</span><br><span class="line">R_ij_B = I_ij_B * (c_ij - r_ij) / (I_ij_B - S_ij_B)</span><br><span class="line">T_ij_B = <span class="number">1</span> / (c_ij - r_ij) * (L_ij_E + L_ij_A - I_ij_A * _L_ij_A / S_ij_A + b_ij + r_ij * _L_ij_A / c_ij)</span><br><span class="line"></span><br><span class="line"><span class="comment"># topo metrics</span></span><br><span class="line">file_path = <span class="string">&quot;SatTopo.txt&quot;</span></span><br><span class="line">r_earth = <span class="number">6371393</span>  <span class="comment"># earth radius 6371km</span></span><br><span class="line">h_sat = <span class="number">600000</span>  <span class="comment"># satellite`s height</span></span><br><span class="line">sat_of_one_orbit = <span class="number">11</span>  <span class="comment"># satellite number of orbit</span></span><br><span class="line">num_of_orbit = <span class="number">6</span>  <span class="comment"># orbit number</span></span><br><span class="line">c_speed = <span class="number">300000000</span>  <span class="comment"># 3*10^8 m/s</span></span><br><span class="line">sat_buffer = <span class="number">1</span> * Mbit  <span class="comment"># sat`s buffer</span></span><br><span class="line">sat_bandwidth = <span class="number">1600</span> * Mbit  <span class="comment"># sat`s bandwidth</span></span><br><span class="line"></span><br><span class="line">simulation_time = <span class="number">10</span>  <span class="comment"># duration time 10s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flow metrics</span></span><br><span class="line">num_of_flow = <span class="number">500</span>  <span class="comment"># simulate 200 flows</span></span><br><span class="line">r_flow = <span class="number">0.08</span> * Mbit  <span class="comment"># flow`s r f=r(t)+b</span></span><br><span class="line">b_flow = <span class="number">0.04</span> * Mbit  <span class="comment"># flow`s b</span></span><br><span class="line">maxdelay_flow = <span class="number">0.5</span>  <span class="comment"># flow`s max delay</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find K paths for one flow</span></span><br><span class="line">num_of_find_K_path = <span class="number">5</span>  <span class="comment"># find 3 path for each flow</span></span><br></pre></td></tr></table></figure>

<p>在input.py文件中，调整CBS、flow、拓扑、找路数量的参数</p>
<h2 id="3-2-main-py"><a href="#3-2-main-py" class="headerlink" title="3.2 main.py"></a>3.2 main.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> SatTopo_update <span class="keyword">import</span> init_topo, get_satisfied_topo, get_k_delay_path, get_delay, flow_init, judge_path_for_flow_in_topo, init_flow_matrix</span><br><span class="line"><span class="keyword">from</span> <span class="built_in">input</span> <span class="keyword">import</span> file_path, sat_bandwidth, sat_buffer, sat_of_one_orbit, num_of_orbit, num_of_flow, r_flow, b_flow, maxdelay_flow, num_of_find_K_path</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line"><span class="comment"># 1.Get Topo</span></span><br><span class="line">sat_topo = init_topo(file_path, <span class="number">1</span>, sat_buffer, sat_bandwidth)</span><br><span class="line">source_node = np.random.randint(<span class="number">1</span>, sat_of_one_orbit * num_of_orbit + <span class="number">1</span>)</span><br><span class="line">target_node = np.random.randint(<span class="number">1</span>, sat_of_one_orbit * num_of_orbit + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.Initiate flows</span></span><br><span class="line">Flow = flow_init(flow_number=num_of_flow, r=r_flow, b=b_flow, delay=maxdelay_flow)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Flow : &quot;</span>, Flow)</span><br><span class="line">flow_succses = <span class="number">0</span></span><br><span class="line">flow_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> flow_count &lt; <span class="built_in">len</span>(Flow):</span><br><span class="line">    flow_selected = Flow[flow_count]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------------new flow :&quot;</span>, flow_selected, <span class="string">&quot;--------------&quot;</span>)</span><br><span class="line">    <span class="comment"># 3.Get K paths and determine</span></span><br><span class="line">    <span class="comment"># 获取满足传输流需求的临时拓扑，在这个临时拓扑上找路径</span></span><br><span class="line">    satisfied_topo = get_satisfied_topo(sat_topo, flow_selected)</span><br><span class="line">    <span class="comment"># 在临时拓扑上找路径，则路径符合端到端时延要求和带宽需求</span></span><br><span class="line">    path = get_k_delay_path(satisfied_topo, flow_selected[<span class="string">&#x27;Source&#x27;</span>],</span><br><span class="line">                            flow_selected[<span class="string">&#x27;Target&#x27;</span>], K=num_of_find_K_path, max_delay=flow_selected[<span class="string">&#x27;maxDelay&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;path：&quot;</span>, path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Length of Path : &quot;</span>, <span class="built_in">len</span>(path))</span><br><span class="line">    <span class="comment"># 4.然后判断路径是否满足缓存需求</span></span><br><span class="line">    path_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">0</span>:</span><br><span class="line">        path_set = []</span><br><span class="line">        <span class="keyword">while</span> path_count &lt; <span class="built_in">len</span>(path):</span><br><span class="line">            <span class="built_in">print</span>(path[path_count])</span><br><span class="line">            [class_a_topo_2, cost, can_trans] = judge_path_for_flow_in_topo \</span><br><span class="line">                (sat_topo, path[path_count], flow_selected, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> can_trans == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 添加这个路径和此路径的花费</span></span><br><span class="line">                path_set.append(&#123;<span class="string">&quot;path&quot;</span>: path[path_count], <span class="string">&quot;cost&quot;</span>: cost&#125;)</span><br><span class="line">            path_count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;cost is :&quot;</span>, cost, <span class="string">&quot;can trans ? &quot;</span>, can_trans)</span><br><span class="line">            <span class="comment"># 5.将符合条件的路径添加到路径集当中</span></span><br><span class="line">        <span class="comment"># 选择路径集中开销最小的路径，作为传输的路径</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path_set) &gt; <span class="number">0</span>:</span><br><span class="line">            path_set = <span class="built_in">sorted</span>(path_set, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;cost&#x27;</span>])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;All path and cost:&quot;</span>, path_set)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;minimum cost path&quot;</span>, path_set[<span class="number">0</span>])</span><br><span class="line">            [sat_topo_2, cost, can_trans] = judge_path_for_flow_in_topo \</span><br><span class="line">                (sat_topo, path_set[<span class="number">0</span>][<span class="string">&#x27;path&#x27;</span>], flow_selected, <span class="number">1</span>)</span><br><span class="line">            sat_topo = sat_topo_2</span><br><span class="line">            flow_succses += can_trans  <span class="comment"># 此流映射成功，flow_succses+1</span></span><br><span class="line">    flow_count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flow_succses)</span><br><span class="line"></span><br><span class="line">end = time.clock()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;running time: &quot;</span>, end-start)</span><br></pre></td></tr></table></figure>

<p>直接运行main.py文件即可。</p>
<h2 id="3-3-测试运行结果"><a href="#3-3-测试运行结果" class="headerlink" title="3.3 测试运行结果"></a>3.3 测试运行结果</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4he3u7dxlj21g30u07bz.jpg" alt="截屏2022-07-24 上午1.44.34"></p>
<p>选择的传输路径为[43,175,32,164,21,153,22,154,12,78,1,67,2,134,69,4,70,5]</p>
<p>第一跳、第二跳…的曲线信息(斜率r、截距b、时间段t0t1)如图中所示。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4he3xttlqj21h90u07fd.jpg" alt="截屏2022-07-24 上午1.44.10"></p>
<p>本次仿真映射了2000条流，总共花了887s，映射成功1998条流，因为映射流后网络拓扑存储的数据会变多。因此映射的流越多，运行时间越长。</p>
<h2 id="3-4-需要更改networkx中shortest-simple-paths的源码，取出找不到路径后的异常抛出"><a href="#3-4-需要更改networkx中shortest-simple-paths的源码，取出找不到路径后的异常抛出" class="headerlink" title="3.4 需要更改networkx中shortest_simple_paths的源码，取出找不到路径后的异常抛出"></a>3.4 需要更改networkx中shortest_simple_paths的源码，取出找不到路径后的异常抛出</h2><p>直接把以下代码全部替换源文件，其实只改了几行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">from</span> networkx.utils <span class="keyword">import</span> not_implemented_for</span><br><span class="line"><span class="keyword">from</span> networkx.utils <span class="keyword">import</span> pairwise</span><br><span class="line"><span class="keyword">from</span> networkx.utils <span class="keyword">import</span> empty_generator</span><br><span class="line"><span class="keyword">from</span> networkx.algorithms.shortest_paths.weighted <span class="keyword">import</span> _weight_function</span><br><span class="line"></span><br><span class="line">__all__ = [</span><br><span class="line">    <span class="string">&quot;all_simple_paths&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_simple_path&quot;</span>,</span><br><span class="line">    <span class="string">&quot;shortest_simple_paths&quot;</span>,</span><br><span class="line">    <span class="string">&quot;all_simple_edge_paths&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_simple_path</span>(<span class="params">G, nodes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if and only if `nodes` form a simple path in `G`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A *simple path* in a graph is a nonempty sequence of nodes in which</span></span><br><span class="line"><span class="string">    no node appears more than once in the sequence, and each adjacent</span></span><br><span class="line"><span class="string">    pair of nodes in the sequence is adjacent in the graph.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    nodes : list</span></span><br><span class="line"><span class="string">        A list of one or more nodes in the graph `G`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    bool</span></span><br><span class="line"><span class="string">        Whether the given list of nodes represents a simple path in `G`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    An empty list of nodes is not a path but a list of one node is a</span></span><br><span class="line"><span class="string">    path. Here&#x27;s an explanation why.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function operates on *node paths*. One could also consider</span></span><br><span class="line"><span class="string">    *edge paths*. There is a bijection between node paths and edge</span></span><br><span class="line"><span class="string">    paths.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The *length of a path* is the number of edges in the path, so a list</span></span><br><span class="line"><span class="string">    of nodes of length *n* corresponds to a path of length *n* - 1.</span></span><br><span class="line"><span class="string">    Thus the smallest edge path would be a list of zero edges, the empty</span></span><br><span class="line"><span class="string">    path. This corresponds to a list of one node.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To convert between a node path and an edge path, you can use code</span></span><br><span class="line"><span class="string">    like the following::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from networkx.utils import pairwise</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; nodes = [0, 1, 2, 3]</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; edges = list(pairwise(nodes))</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; edges</span></span><br><span class="line"><span class="string">        [(0, 1), (1, 2), (2, 3)]</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; nodes = [edges[0][0]] + [v for u, v in edges]</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; nodes</span></span><br><span class="line"><span class="string">        [0, 1, 2, 3]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; G = nx.cycle_graph(4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; nx.is_simple_path(G, [2, 3, 0])</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; nx.is_simple_path(G, [0, 2])</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># The empty list is not a valid path. Could also return</span></span><br><span class="line">    <span class="comment"># NetworkXPointlessConcept here.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># If the list is a single node, just check that the node is actually</span></span><br><span class="line">    <span class="comment"># in the graph.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>] <span class="keyword">in</span> G</span><br><span class="line">    <span class="comment"># Test that no node appears more than once, and that each</span></span><br><span class="line">    <span class="comment"># adjacent pair of nodes is adjacent.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nodes)) == <span class="built_in">len</span>(nodes) <span class="keyword">and</span> <span class="built_in">all</span>(v <span class="keyword">in</span> G[u] <span class="keyword">for</span> u, v <span class="keyword">in</span> pairwise(nodes))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_simple_paths</span>(<span class="params">G, source, target, cutoff=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate all simple paths in the graph G from source to target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A simple path is a path with no repeated nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    G : NetworkX graph</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    source : node</span></span><br><span class="line"><span class="string">       Starting node for path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    target : nodes</span></span><br><span class="line"><span class="string">       Single node or iterable of nodes at which to end path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cutoff : integer, optional</span></span><br><span class="line"><span class="string">        Depth to stop the search. Only paths of length &lt;= cutoff are returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    path_generator: generator</span></span><br><span class="line"><span class="string">       A generator that produces lists of simple paths.  If there are no paths</span></span><br><span class="line"><span class="string">       between the source and target within the given cutoff the generator</span></span><br><span class="line"><span class="string">       produces no output.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    This iterator generates lists of nodes::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.complete_graph(4)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in nx.all_simple_paths(G, source=0, target=3):</span></span><br><span class="line"><span class="string">        ...     print(path)</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">        [0, 1, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 3]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You can generate only those paths that are shorter than a certain</span></span><br><span class="line"><span class="string">    length by using the `cutoff` keyword argument::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; print(list(paths))</span></span><br><span class="line"><span class="string">        [[0, 1, 3], [0, 2, 3], [0, 3]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To get each path as the corresponding list of edges, you can use the</span></span><br><span class="line"><span class="string">    :func:`networkx.utils.pairwise` helper function::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; paths = nx.all_simple_paths(G, source=0, target=3)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in map(nx.utils.pairwise, paths):</span></span><br><span class="line"><span class="string">        ...     print(list(path))</span></span><br><span class="line"><span class="string">        [(0, 1), (1, 2), (2, 3)]</span></span><br><span class="line"><span class="string">        [(0, 1), (1, 3)]</span></span><br><span class="line"><span class="string">        [(0, 2), (2, 1), (1, 3)]</span></span><br><span class="line"><span class="string">        [(0, 2), (2, 3)]</span></span><br><span class="line"><span class="string">        [(0, 3)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Pass an iterable of nodes as target to generate all paths ending in any of several nodes::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.complete_graph(4)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in nx.all_simple_paths(G, source=0, target=[3, 2]):</span></span><br><span class="line"><span class="string">        ...     print(path)</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">        [0, 1, 2]</span></span><br><span class="line"><span class="string">        [0, 1, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 1, 3, 2]</span></span><br><span class="line"><span class="string">        [0, 2]</span></span><br><span class="line"><span class="string">        [0, 2, 1, 3]</span></span><br><span class="line"><span class="string">        [0, 2, 3]</span></span><br><span class="line"><span class="string">        [0, 3]</span></span><br><span class="line"><span class="string">        [0, 3, 1, 2]</span></span><br><span class="line"><span class="string">        [0, 3, 2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Iterate over each path from the root nodes to the leaf nodes in a</span></span><br><span class="line"><span class="string">    directed acyclic graph using a functional programming approach::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import chain</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import product</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from itertools import starmap</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from functools import partial</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; chaini = chain.from_iterable</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = (v for v, d in G.out_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = partial(nx.all_simple_paths, G)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; list(chaini(starmap(all_paths, product(roots, leaves))))</span></span><br><span class="line"><span class="string">        [[0, 1, 2], [0, 3, 2]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The same list computed using an iterative approach::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = (v for v, d in G.out_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = []</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for root in roots:</span></span><br><span class="line"><span class="string">        ...     for leaf in leaves:</span></span><br><span class="line"><span class="string">        ...         paths = nx.all_simple_paths(G, root, leaf)</span></span><br><span class="line"><span class="string">        ...         all_paths.extend(paths)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths</span></span><br><span class="line"><span class="string">        [[0, 1, 2], [0, 3, 2]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Iterate over each path from the root nodes to the leaf nodes in a</span></span><br><span class="line"><span class="string">    directed acyclic graph passing all leaves together to avoid unnecessary</span></span><br><span class="line"><span class="string">    compute::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; leaves = [v for v, d in G.out_degree() if d == 0]</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths = []</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for root in roots:</span></span><br><span class="line"><span class="string">        ...     paths = nx.all_simple_paths(G, root, leaves)</span></span><br><span class="line"><span class="string">        ...     all_paths.extend(paths)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; all_paths</span></span><br><span class="line"><span class="string">        [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    This algorithm uses a modified depth-first search to generate the</span></span><br><span class="line"><span class="string">    paths [1]_.  A single path can be found in $O(V+E)$ time but the</span></span><br><span class="line"><span class="string">    number of simple paths in a graph can be very large, e.g. $O(n!)$ in</span></span><br><span class="line"><span class="string">    the complete graph of order $n$.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    References</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    .. [1] R. Sedgewick, &quot;Algorithms in C, Part 5: Graph Algorithms&quot;,</span></span><br><span class="line"><span class="string">       Addison Wesley Professional, 3rd ed., 2001.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    all_shortest_paths, shortest_path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">        <span class="keyword">raise</span> nx.NodeNotFound(<span class="string">f&quot;source node <span class="subst">&#123;source&#125;</span> not in graph&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">in</span> G:</span><br><span class="line">        targets = &#123;target&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            targets = <span class="built_in">set</span>(target)</span><br><span class="line">        <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> nx.NodeNotFound(<span class="string">f&quot;target node <span class="subst">&#123;target&#125;</span> not in graph&quot;</span>) <span class="keyword">from</span> e</span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">in</span> targets:</span><br><span class="line">        <span class="keyword">return</span> empty_generator()</span><br><span class="line">    <span class="keyword">if</span> cutoff <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cutoff = <span class="built_in">len</span>(G) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cutoff &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> empty_generator()</span><br><span class="line">    <span class="keyword">if</span> G.is_multigraph():</span><br><span class="line">        <span class="keyword">return</span> _all_simple_paths_multigraph(G, source, targets, cutoff)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> _all_simple_paths_graph(G, source, targets, cutoff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_all_simple_paths_graph</span>(<span class="params">G, source, targets, cutoff</span>):</span><br><span class="line">    visited = <span class="built_in">dict</span>.fromkeys([source])</span><br><span class="line">    stack = [<span class="built_in">iter</span>(G[source])]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        children = stack[-<span class="number">1</span>]</span><br><span class="line">        child = <span class="built_in">next</span>(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">list</span>(visited) + [child]</span><br><span class="line">            visited[child] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> targets - <span class="built_in">set</span>(visited.keys()):  <span class="comment"># expand stack until find all targets</span></span><br><span class="line">                stack.append(<span class="built_in">iter</span>(G[child]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.popitem()  <span class="comment"># maybe other ways to child</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> (targets &amp; (<span class="built_in">set</span>(children) | &#123;child&#125;)) - <span class="built_in">set</span>(visited.keys()):</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">list</span>(visited) + [target]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_all_simple_paths_multigraph</span>(<span class="params">G, source, targets, cutoff</span>):</span><br><span class="line">    visited = <span class="built_in">dict</span>.fromkeys([source])</span><br><span class="line">    stack = [(v <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges(source))]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        children = stack[-<span class="number">1</span>]</span><br><span class="line">        child = <span class="built_in">next</span>(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">list</span>(visited) + [child]</span><br><span class="line">            visited[child] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> targets - <span class="built_in">set</span>(visited.keys()):</span><br><span class="line">                stack.append((v <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges(child)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.popitem()</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> targets - <span class="built_in">set</span>(visited.keys()):</span><br><span class="line">                count = ([child] + <span class="built_in">list</span>(children)).count(target)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">                    <span class="keyword">yield</span> <span class="built_in">list</span>(visited) + [target]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.popitem()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_simple_edge_paths</span>(<span class="params">G, source, target, cutoff=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate lists of edges for all simple paths in G from source to target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A simple path is a path with no repeated nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    G : NetworkX graph</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    source : node</span></span><br><span class="line"><span class="string">       Starting node for path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    target : nodes</span></span><br><span class="line"><span class="string">       Single node or iterable of nodes at which to end path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cutoff : integer, optional</span></span><br><span class="line"><span class="string">        Depth to stop the search. Only paths of length &lt;= cutoff are returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    path_generator: generator</span></span><br><span class="line"><span class="string">       A generator that produces lists of simple paths.  If there are no paths</span></span><br><span class="line"><span class="string">       between the source and target within the given cutoff the generator</span></span><br><span class="line"><span class="string">       produces no output.</span></span><br><span class="line"><span class="string">       For multigraphs, the list of edges have elements of the form `(u,v,k)`.</span></span><br><span class="line"><span class="string">       Where `k` corresponds to the edge key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Print the simple path edges of a Graph::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; g = nx.Graph([(1, 2), (2, 4), (1, 3), (3, 4)])</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in sorted(nx.all_simple_edge_paths(g, 1, 4)):</span></span><br><span class="line"><span class="string">        ...     print(path)</span></span><br><span class="line"><span class="string">        [(1, 2), (2, 4)]</span></span><br><span class="line"><span class="string">        [(1, 3), (3, 4)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Print the simple path edges of a MultiGraph. Returned edges come with</span></span><br><span class="line"><span class="string">    their associated keys::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; mg = nx.MultiGraph()</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; mg.add_edge(1, 2, key=&quot;k0&quot;)</span></span><br><span class="line"><span class="string">        &#x27;k0&#x27;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; mg.add_edge(1, 2, key=&quot;k1&quot;)</span></span><br><span class="line"><span class="string">        &#x27;k1&#x27;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; mg.add_edge(2, 3, key=&quot;k0&quot;)</span></span><br><span class="line"><span class="string">        &#x27;k0&#x27;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for path in sorted(nx.all_simple_edge_paths(mg, 1, 3)):</span></span><br><span class="line"><span class="string">        ...     print(path)</span></span><br><span class="line"><span class="string">        [(1, 2, &#x27;k0&#x27;), (2, 3, &#x27;k0&#x27;)]</span></span><br><span class="line"><span class="string">        [(1, 2, &#x27;k1&#x27;), (2, 3, &#x27;k0&#x27;)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    This algorithm uses a modified depth-first search to generate the</span></span><br><span class="line"><span class="string">    paths [1]_.  A single path can be found in $O(V+E)$ time but the</span></span><br><span class="line"><span class="string">    number of simple paths in a graph can be very large, e.g. $O(n!)$ in</span></span><br><span class="line"><span class="string">    the complete graph of order $n$.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    References</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    .. [1] R. Sedgewick, &quot;Algorithms in C, Part 5: Graph Algorithms&quot;,</span></span><br><span class="line"><span class="string">       Addison Wesley Professional, 3rd ed., 2001.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    all_shortest_paths, shortest_path, all_simple_paths</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">        <span class="keyword">raise</span> nx.NodeNotFound(<span class="string">&quot;source node %s not in graph&quot;</span> % source)</span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">in</span> G:</span><br><span class="line">        targets = &#123;target&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            targets = <span class="built_in">set</span>(target)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            <span class="keyword">raise</span> nx.NodeNotFound(<span class="string">&quot;target node %s not in graph&quot;</span> % target)</span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">in</span> targets:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> cutoff <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cutoff = <span class="built_in">len</span>(G) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cutoff &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> G.is_multigraph():</span><br><span class="line">        <span class="keyword">for</span> simp_path <span class="keyword">in</span> _all_simple_edge_paths_multigraph(G, source, targets, cutoff):</span><br><span class="line">            <span class="keyword">yield</span> simp_path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> simp_path <span class="keyword">in</span> _all_simple_paths_graph(G, source, targets, cutoff):</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(simp_path[:-<span class="number">1</span>], simp_path[<span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_all_simple_edge_paths_multigraph</span>(<span class="params">G, source, targets, cutoff</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cutoff <span class="keyword">or</span> cutoff &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    visited = [source]</span><br><span class="line">    stack = [<span class="built_in">iter</span>(G.edges(source, keys=<span class="literal">True</span>))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        children = stack[-<span class="number">1</span>]</span><br><span class="line">        child = <span class="built_in">next</span>(children, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.pop()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(visited) &lt; cutoff:</span><br><span class="line">            <span class="keyword">if</span> child[<span class="number">1</span>] <span class="keyword">in</span> targets:</span><br><span class="line">                <span class="keyword">yield</span> visited[<span class="number">1</span>:] + [child]</span><br><span class="line">            <span class="keyword">elif</span> child[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [v[<span class="number">0</span>] <span class="keyword">for</span> v <span class="keyword">in</span> visited[<span class="number">1</span>:]]:</span><br><span class="line">                visited.append(child)</span><br><span class="line">                stack.append(<span class="built_in">iter</span>(G.edges(child[<span class="number">1</span>], keys=<span class="literal">True</span>)))</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># len(visited) == cutoff:</span></span><br><span class="line">            <span class="keyword">for</span> (u, v, k) <span class="keyword">in</span> [child] + <span class="built_in">list</span>(children):</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">in</span> targets:</span><br><span class="line">                    <span class="keyword">yield</span> visited[<span class="number">1</span>:] + [(u, v, k)]</span><br><span class="line">            stack.pop()</span><br><span class="line">            visited.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@not_implemented_for(<span class="params"><span class="string">&quot;multigraph&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shortest_simple_paths</span>(<span class="params">G, source, target, weight=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate all simple paths in the graph G from source to target,</span></span><br><span class="line"><span class="string">       starting from shortest ones.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A simple path is a path with no repeated nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If a weighted shortest path search is to be used, no negative weights</span></span><br><span class="line"><span class="string">    are allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    G : NetworkX graph</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    source : node</span></span><br><span class="line"><span class="string">       Starting node for path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    target : node</span></span><br><span class="line"><span class="string">       Ending node for path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    weight : string or function</span></span><br><span class="line"><span class="string">        If it is a string, it is the name of the edge attribute to be</span></span><br><span class="line"><span class="string">        used as a weight.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If it is a function, the weight of an edge is the value returned</span></span><br><span class="line"><span class="string">        by the function. The function must accept exactly three positional</span></span><br><span class="line"><span class="string">        arguments: the two endpoints of an edge and the dictionary of edge</span></span><br><span class="line"><span class="string">        attributes for that edge. The function must return a number.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If None all edges are considered to have unit weight. Default</span></span><br><span class="line"><span class="string">        value None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    path_generator: generator</span></span><br><span class="line"><span class="string">       A generator that produces lists of simple paths, in order from</span></span><br><span class="line"><span class="string">       shortest to longest.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises</span></span><br><span class="line"><span class="string">    ------</span></span><br><span class="line"><span class="string">    NetworkXNoPath</span></span><br><span class="line"><span class="string">       If no path exists between source and target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    NetworkXError</span></span><br><span class="line"><span class="string">       If source or target nodes are not in the input graph.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    NetworkXNotImplemented</span></span><br><span class="line"><span class="string">       If the input graph is a Multi[Di]Graph.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; G = nx.cycle_graph(7)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; paths = list(nx.shortest_simple_paths(G, 0, 3))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(paths)</span></span><br><span class="line"><span class="string">    [[0, 1, 2, 3], [0, 6, 5, 4, 3]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You can use this function to efficiently compute the k shortest/best</span></span><br><span class="line"><span class="string">    paths between two nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from itertools import islice</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; def k_shortest_paths(G, source, target, k, weight=None):</span></span><br><span class="line"><span class="string">    ...     return list(</span></span><br><span class="line"><span class="string">    ...         islice(nx.shortest_simple_paths(G, source, target, weight=weight), k)</span></span><br><span class="line"><span class="string">    ...     )</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; for path in k_shortest_paths(G, 0, 3, 2):</span></span><br><span class="line"><span class="string">    ...     print(path)</span></span><br><span class="line"><span class="string">    [0, 1, 2, 3]</span></span><br><span class="line"><span class="string">    [0, 6, 5, 4, 3]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    This procedure is based on algorithm by Jin Y. Yen [1]_.  Finding</span></span><br><span class="line"><span class="string">    the first $K$ paths requires $O(KN^3)$ operations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    all_shortest_paths</span></span><br><span class="line"><span class="string">    shortest_path</span></span><br><span class="line"><span class="string">    all_simple_paths</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    References</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    .. [1] Jin Y. Yen, &quot;Finding the K Shortest Loopless Paths in a</span></span><br><span class="line"><span class="string">       Network&quot;, Management Science, Vol. 17, No. 11, Theory Series</span></span><br><span class="line"><span class="string">       (Jul., 1971), pp. 712-716.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> source <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">        <span class="comment">#raise nx.NodeNotFound(f&quot;source node &#123;source&#125; not in graph&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">        <span class="comment">#raise nx.NodeNotFound(f&quot;target node &#123;target&#125; not in graph&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> weight <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        length_func = <span class="built_in">len</span></span><br><span class="line">        shortest_path_func = _bidirectional_shortest_path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wt = _weight_function(G, weight)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">length_func</span>(<span class="params">path</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(</span><br><span class="line">                wt(u, v, G.get_edge_data(u, v)) <span class="keyword">for</span> (u, v) <span class="keyword">in</span> <span class="built_in">zip</span>(path, path[<span class="number">1</span>:])</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        shortest_path_func = _bidirectional_dijkstra</span><br><span class="line"></span><br><span class="line">    listA = <span class="built_in">list</span>()</span><br><span class="line">    listB = PathBuffer()</span><br><span class="line">    prev_path = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prev_path:</span><br><span class="line">            length, path = shortest_path_func(G, source, target, weight=weight)</span><br><span class="line">            <span class="keyword">if</span> path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            listB.push(length, path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ignore_nodes = <span class="built_in">set</span>()</span><br><span class="line">            ignore_edges = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prev_path)):</span><br><span class="line">                root = prev_path[:i]</span><br><span class="line">                root_length = length_func(root)</span><br><span class="line">                <span class="keyword">for</span> path <span class="keyword">in</span> listA:</span><br><span class="line">                    <span class="keyword">if</span> path[:i] == root:</span><br><span class="line">                        ignore_edges.add((path[i - <span class="number">1</span>], path[i]))</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    length, spur = shortest_path_func(</span><br><span class="line">                        G,</span><br><span class="line">                        root[-<span class="number">1</span>],</span><br><span class="line">                        target,</span><br><span class="line">                        ignore_nodes=ignore_nodes,</span><br><span class="line">                        ignore_edges=ignore_edges,</span><br><span class="line">                        weight=weight,</span><br><span class="line">                    )</span><br><span class="line">                    <span class="keyword">if</span> spur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                    path = root[:-<span class="number">1</span>] + spur</span><br><span class="line">                    listB.push(root_length + length, path)</span><br><span class="line">                <span class="keyword">except</span> nx.NetworkXNoPath:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                ignore_nodes.add(root[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> listB:</span><br><span class="line">            path = listB.pop()</span><br><span class="line">            <span class="keyword">yield</span> path</span><br><span class="line">            listA.append(path)</span><br><span class="line">            prev_path = path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PathBuffer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.paths = <span class="built_in">set</span>()</span><br><span class="line">        self.sortedpaths = <span class="built_in">list</span>()</span><br><span class="line">        self.counter = count()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.sortedpaths)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, cost, path</span>):</span><br><span class="line">        hashable_path = <span class="built_in">tuple</span>(path)</span><br><span class="line">        <span class="keyword">if</span> hashable_path <span class="keyword">not</span> <span class="keyword">in</span> self.paths:</span><br><span class="line">            heappush(self.sortedpaths, (cost, <span class="built_in">next</span>(self.counter), path))</span><br><span class="line">            self.paths.add(hashable_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        (cost, num, path) = heappop(self.sortedpaths)</span><br><span class="line">        hashable_path = <span class="built_in">tuple</span>(path)</span><br><span class="line">        self.paths.remove(hashable_path)</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_bidirectional_shortest_path</span>(<span class="params"></span></span><br><span class="line"><span class="params">    G, source, target, ignore_nodes=<span class="literal">None</span>, ignore_edges=<span class="literal">None</span>, weight=<span class="literal">None</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns the shortest path between source and target ignoring</span></span><br><span class="line"><span class="string">       nodes and edges in the containers ignore_nodes and ignore_edges.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is a custom modification of the standard bidirectional shortest</span></span><br><span class="line"><span class="string">    path implementation at networkx.algorithms.unweighted</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    G : NetworkX graph</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    source : node</span></span><br><span class="line"><span class="string">       starting node for path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    target : node</span></span><br><span class="line"><span class="string">       ending node for path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ignore_nodes : container of nodes</span></span><br><span class="line"><span class="string">       nodes to ignore, optional</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ignore_edges : container of edges</span></span><br><span class="line"><span class="string">       edges to ignore, optional</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    weight : None</span></span><br><span class="line"><span class="string">       This function accepts a weight argument for convenience of</span></span><br><span class="line"><span class="string">       shortest_simple_paths function. It will be ignored.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    path: list</span></span><br><span class="line"><span class="string">       List of nodes in a path from source to target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises</span></span><br><span class="line"><span class="string">    ------</span></span><br><span class="line"><span class="string">    NetworkXNoPath</span></span><br><span class="line"><span class="string">       If no path exists between source and target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    shortest_path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># call helper to do the real work</span></span><br><span class="line">    results = _bidirectional_pred_succ(G, source, target, ignore_nodes, ignore_edges)</span><br><span class="line">    pred, succ, w = results</span><br><span class="line"></span><br><span class="line">    <span class="comment"># build path from pred+w+succ</span></span><br><span class="line">    path = []</span><br><span class="line">    <span class="comment"># from w to target</span></span><br><span class="line">    <span class="keyword">while</span> w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        path.append(w)</span><br><span class="line">        w = succ[w]</span><br><span class="line">    <span class="comment"># from source to w</span></span><br><span class="line">    w = pred[path[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        path.insert(<span class="number">0</span>, w)</span><br><span class="line">        w = pred[w]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(path), path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_bidirectional_pred_succ</span>(<span class="params">G, source, target, ignore_nodes=<span class="literal">None</span>, ignore_edges=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Bidirectional shortest path helper.</span></span><br><span class="line"><span class="string">       Returns (pred,succ,w) where</span></span><br><span class="line"><span class="string">       pred is a dictionary of predecessors from w to the source, and</span></span><br><span class="line"><span class="string">       succ is a dictionary of successors from w to the target.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># does BFS from both source and target and meets in the middle</span></span><br><span class="line">    <span class="keyword">if</span> ignore_nodes <span class="keyword">and</span> (source <span class="keyword">in</span> ignore_nodes <span class="keyword">or</span> target <span class="keyword">in</span> ignore_nodes):</span><br><span class="line">        <span class="keyword">raise</span> nx.NetworkXNoPath(<span class="string">f&quot;No path between <span class="subst">&#123;source&#125;</span> and <span class="subst">&#123;target&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> target == source:</span><br><span class="line">        <span class="keyword">return</span> (&#123;target: <span class="literal">None</span>&#125;, &#123;source: <span class="literal">None</span>&#125;, source)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># handle either directed or undirected</span></span><br><span class="line">    <span class="keyword">if</span> G.is_directed():</span><br><span class="line">        Gpred = G.predecessors</span><br><span class="line">        Gsucc = G.successors</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Gpred = G.neighbors</span><br><span class="line">        Gsucc = G.neighbors</span><br><span class="line"></span><br><span class="line">    <span class="comment"># support optional nodes filter</span></span><br><span class="line">    <span class="keyword">if</span> ignore_nodes:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">filter_iter</span>(<span class="params">nodes</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">v</span>):</span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> nodes(v):</span><br><span class="line">                    <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> ignore_nodes:</span><br><span class="line">                        <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> iterate</span><br><span class="line"></span><br><span class="line">        Gpred = filter_iter(Gpred)</span><br><span class="line">        Gsucc = filter_iter(Gsucc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># support optional edges filter</span></span><br><span class="line">    <span class="keyword">if</span> ignore_edges:</span><br><span class="line">        <span class="keyword">if</span> G.is_directed():</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">filter_pred_iter</span>(<span class="params">pred_iter</span>):</span><br><span class="line">                <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">v</span>):</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> pred_iter(v):</span><br><span class="line">                        <span class="keyword">if</span> (w, v) <span class="keyword">not</span> <span class="keyword">in</span> ignore_edges:</span><br><span class="line">                            <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> iterate</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">filter_succ_iter</span>(<span class="params">succ_iter</span>):</span><br><span class="line">                <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">v</span>):</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> succ_iter(v):</span><br><span class="line">                        <span class="keyword">if</span> (v, w) <span class="keyword">not</span> <span class="keyword">in</span> ignore_edges:</span><br><span class="line">                            <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> iterate</span><br><span class="line"></span><br><span class="line">            Gpred = filter_pred_iter(Gpred)</span><br><span class="line">            Gsucc = filter_succ_iter(Gsucc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">filter_iter</span>(<span class="params">nodes</span>):</span><br><span class="line">                <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">v</span>):</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> nodes(v):</span><br><span class="line">                        <span class="keyword">if</span> (v, w) <span class="keyword">not</span> <span class="keyword">in</span> ignore_edges <span class="keyword">and</span> (w, v) <span class="keyword">not</span> <span class="keyword">in</span> ignore_edges:</span><br><span class="line">                            <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> iterate</span><br><span class="line"></span><br><span class="line">            Gpred = filter_iter(Gpred)</span><br><span class="line">            Gsucc = filter_iter(Gsucc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># predecesssor and successors in search</span></span><br><span class="line">    pred = &#123;source: <span class="literal">None</span>&#125;</span><br><span class="line">    succ = &#123;target: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize fringes, start with forward</span></span><br><span class="line">    forward_fringe = [source]</span><br><span class="line">    reverse_fringe = [target]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> forward_fringe <span class="keyword">and</span> reverse_fringe:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(forward_fringe) &lt;= <span class="built_in">len</span>(reverse_fringe):</span><br><span class="line">            this_level = forward_fringe</span><br><span class="line">            forward_fringe = []</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> this_level:</span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> Gsucc(v):</span><br><span class="line">                    <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> pred:</span><br><span class="line">                        forward_fringe.append(w)</span><br><span class="line">                        pred[w] = v</span><br><span class="line">                    <span class="keyword">if</span> w <span class="keyword">in</span> succ:</span><br><span class="line">                        <span class="comment"># found path</span></span><br><span class="line">                        <span class="keyword">return</span> pred, succ, w</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            this_level = reverse_fringe</span><br><span class="line">            reverse_fringe = []</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> this_level:</span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> Gpred(v):</span><br><span class="line">                    <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> succ:</span><br><span class="line">                        succ[w] = v</span><br><span class="line">                        reverse_fringe.append(w)</span><br><span class="line">                    <span class="keyword">if</span> w <span class="keyword">in</span> pred:</span><br><span class="line">                        <span class="comment"># found path</span></span><br><span class="line">                        <span class="keyword">return</span> pred, succ, w</span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> nx.NetworkXNoPath(<span class="string">f&quot;No path between <span class="subst">&#123;source&#125;</span> and <span class="subst">&#123;target&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_bidirectional_dijkstra</span>(<span class="params"></span></span><br><span class="line"><span class="params">    G, source, target, weight=<span class="string">&quot;weight&quot;</span>, ignore_nodes=<span class="literal">None</span>, ignore_edges=<span class="literal">None</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Dijkstra&#x27;s algorithm for shortest paths using bidirectional search.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function returns the shortest path between source and target</span></span><br><span class="line"><span class="string">    ignoring nodes and edges in the containers ignore_nodes and</span></span><br><span class="line"><span class="string">    ignore_edges.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is a custom modification of the standard Dijkstra bidirectional</span></span><br><span class="line"><span class="string">    shortest path implementation at networkx.algorithms.weighted</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    G : NetworkX graph</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    source : node</span></span><br><span class="line"><span class="string">       Starting node.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    target : node</span></span><br><span class="line"><span class="string">       Ending node.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    weight: string, function, optional (default=&#x27;weight&#x27;)</span></span><br><span class="line"><span class="string">       Edge data key or weight function corresponding to the edge weight</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ignore_nodes : container of nodes</span></span><br><span class="line"><span class="string">       nodes to ignore, optional</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ignore_edges : container of edges</span></span><br><span class="line"><span class="string">       edges to ignore, optional</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    length : number</span></span><br><span class="line"><span class="string">        Shortest path length.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns a tuple of two dictionaries keyed by node.</span></span><br><span class="line"><span class="string">    The first dictionary stores distance from the source.</span></span><br><span class="line"><span class="string">    The second stores the path from the source to that node.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises</span></span><br><span class="line"><span class="string">    ------</span></span><br><span class="line"><span class="string">    NetworkXNoPath</span></span><br><span class="line"><span class="string">        If no path exists between source and target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    Edge weight attributes must be numerical.</span></span><br><span class="line"><span class="string">    Distances are calculated as sums of weighted edges traversed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In practice  bidirectional Dijkstra is much more than twice as fast as</span></span><br><span class="line"><span class="string">    ordinary Dijkstra.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Ordinary Dijkstra expands nodes in a sphere-like manner from the</span></span><br><span class="line"><span class="string">    source. The radius of this sphere will eventually be the length</span></span><br><span class="line"><span class="string">    of the shortest path. Bidirectional Dijkstra will expand nodes</span></span><br><span class="line"><span class="string">    from both the source and the target, making two spheres of half</span></span><br><span class="line"><span class="string">    this radius. Volume of the first sphere is pi*r*r while the</span></span><br><span class="line"><span class="string">    others are 2*pi*r/2*r/2, making up half the volume.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This algorithm is not guaranteed to work if edge weights</span></span><br><span class="line"><span class="string">    are negative or are floating point numbers</span></span><br><span class="line"><span class="string">    (overflows and roundoff errors can cause problems).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See Also</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    shortest_path</span></span><br><span class="line"><span class="string">    shortest_path_length</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ignore_nodes <span class="keyword">and</span> (source <span class="keyword">in</span> ignore_nodes <span class="keyword">or</span> target <span class="keyword">in</span> ignore_nodes):</span><br><span class="line">        <span class="keyword">raise</span> nx.NetworkXNoPath(<span class="string">f&quot;No path between <span class="subst">&#123;source&#125;</span> and <span class="subst">&#123;target&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> source == target:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>, [source])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># handle either directed or undirected</span></span><br><span class="line">    <span class="keyword">if</span> G.is_directed():</span><br><span class="line">        Gpred = G.predecessors</span><br><span class="line">        Gsucc = G.successors</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Gpred = G.neighbors</span><br><span class="line">        Gsucc = G.neighbors</span><br><span class="line"></span><br><span class="line">    <span class="comment"># support optional nodes filter</span></span><br><span class="line">    <span class="keyword">if</span> ignore_nodes:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">filter_iter</span>(<span class="params">nodes</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">v</span>):</span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> nodes(v):</span><br><span class="line">                    <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> ignore_nodes:</span><br><span class="line">                        <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> iterate</span><br><span class="line"></span><br><span class="line">        Gpred = filter_iter(Gpred)</span><br><span class="line">        Gsucc = filter_iter(Gsucc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># support optional edges filter</span></span><br><span class="line">    <span class="keyword">if</span> ignore_edges:</span><br><span class="line">        <span class="keyword">if</span> G.is_directed():</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">filter_pred_iter</span>(<span class="params">pred_iter</span>):</span><br><span class="line">                <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">v</span>):</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> pred_iter(v):</span><br><span class="line">                        <span class="keyword">if</span> (w, v) <span class="keyword">not</span> <span class="keyword">in</span> ignore_edges:</span><br><span class="line">                            <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> iterate</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">filter_succ_iter</span>(<span class="params">succ_iter</span>):</span><br><span class="line">                <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">v</span>):</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> succ_iter(v):</span><br><span class="line">                        <span class="keyword">if</span> (v, w) <span class="keyword">not</span> <span class="keyword">in</span> ignore_edges:</span><br><span class="line">                            <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> iterate</span><br><span class="line"></span><br><span class="line">            Gpred = filter_pred_iter(Gpred)</span><br><span class="line">            Gsucc = filter_succ_iter(Gsucc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">filter_iter</span>(<span class="params">nodes</span>):</span><br><span class="line">                <span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">v</span>):</span><br><span class="line">                    <span class="keyword">for</span> w <span class="keyword">in</span> nodes(v):</span><br><span class="line">                        <span class="keyword">if</span> (v, w) <span class="keyword">not</span> <span class="keyword">in</span> ignore_edges <span class="keyword">and</span> (w, v) <span class="keyword">not</span> <span class="keyword">in</span> ignore_edges:</span><br><span class="line">                            <span class="keyword">yield</span> w</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> iterate</span><br><span class="line"></span><br><span class="line">            Gpred = filter_iter(Gpred)</span><br><span class="line">            Gsucc = filter_iter(Gsucc)</span><br><span class="line"></span><br><span class="line">    push = heappush</span><br><span class="line">    pop = heappop</span><br><span class="line">    <span class="comment"># Init:   Forward             Backward</span></span><br><span class="line">    dists = [&#123;&#125;, &#123;&#125;]  <span class="comment"># dictionary of final distances</span></span><br><span class="line">    paths = [&#123;source: [source]&#125;, &#123;target: [target]&#125;]  <span class="comment"># dictionary of paths</span></span><br><span class="line">    fringe = [[], []]  <span class="comment"># heap of (distance, node) tuples for</span></span><br><span class="line">    <span class="comment"># extracting next node to expand</span></span><br><span class="line">    seen = [&#123;source: <span class="number">0</span>&#125;, &#123;target: <span class="number">0</span>&#125;]  <span class="comment"># dictionary of distances to</span></span><br><span class="line">    <span class="comment"># nodes seen</span></span><br><span class="line">    c = count()</span><br><span class="line">    <span class="comment"># initialize fringe heap</span></span><br><span class="line">    push(fringe[<span class="number">0</span>], (<span class="number">0</span>, <span class="built_in">next</span>(c), source))</span><br><span class="line">    push(fringe[<span class="number">1</span>], (<span class="number">0</span>, <span class="built_in">next</span>(c), target))</span><br><span class="line">    <span class="comment"># neighs for extracting correct neighbor information</span></span><br><span class="line">    neighs = [Gsucc, Gpred]</span><br><span class="line">    <span class="comment"># variables to hold shortest discovered path</span></span><br><span class="line">    <span class="comment"># finaldist = 1e30000</span></span><br><span class="line">    finalpath = []</span><br><span class="line">    <span class="built_in">dir</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> fringe[<span class="number">0</span>] <span class="keyword">and</span> fringe[<span class="number">1</span>]:</span><br><span class="line">        <span class="comment"># choose direction</span></span><br><span class="line">        <span class="comment"># dir == 0 is forward direction and dir == 1 is back</span></span><br><span class="line">        <span class="built_in">dir</span> = <span class="number">1</span> - <span class="built_in">dir</span></span><br><span class="line">        <span class="comment"># extract closest to expand</span></span><br><span class="line">        (dist, _, v) = pop(fringe[<span class="built_in">dir</span>])</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">in</span> dists[<span class="built_in">dir</span>]:</span><br><span class="line">            <span class="comment"># Shortest path to v has already been found</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># update distance</span></span><br><span class="line">        dists[<span class="built_in">dir</span>][v] = dist  <span class="comment"># equal to seen[dir][v]</span></span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">in</span> dists[<span class="number">1</span> - <span class="built_in">dir</span>]:</span><br><span class="line">            <span class="comment"># if we have scanned v in both directions we are done</span></span><br><span class="line">            <span class="comment"># we have now discovered the shortest path</span></span><br><span class="line">            <span class="keyword">return</span> (finaldist, finalpath)</span><br><span class="line"></span><br><span class="line">        wt = _weight_function(G, weight)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> neighs[<span class="built_in">dir</span>](v):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">dir</span> == <span class="number">0</span>:  <span class="comment"># forward</span></span><br><span class="line">                minweight = wt(v, w, G.get_edge_data(v, w))</span><br><span class="line">                vwLength = dists[<span class="built_in">dir</span>][v] + minweight</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># back, must remember to change v,w-&gt;w,v</span></span><br><span class="line">                minweight = wt(w, v, G.get_edge_data(w, v))</span><br><span class="line">                vwLength = dists[<span class="built_in">dir</span>][v] + minweight</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> dists[<span class="built_in">dir</span>]:</span><br><span class="line">                <span class="keyword">if</span> vwLength &lt; dists[<span class="built_in">dir</span>][w]:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Contradictory paths found: negative weights?&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> w <span class="keyword">not</span> <span class="keyword">in</span> seen[<span class="built_in">dir</span>] <span class="keyword">or</span> vwLength &lt; seen[<span class="built_in">dir</span>][w]:</span><br><span class="line">                <span class="comment"># relaxing</span></span><br><span class="line">                seen[<span class="built_in">dir</span>][w] = vwLength</span><br><span class="line">                push(fringe[<span class="built_in">dir</span>], (vwLength, <span class="built_in">next</span>(c), w))</span><br><span class="line">                paths[<span class="built_in">dir</span>][w] = paths[<span class="built_in">dir</span>][v] + [w]</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">in</span> seen[<span class="number">0</span>] <span class="keyword">and</span> w <span class="keyword">in</span> seen[<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># see if this path is better than than the already</span></span><br><span class="line">                    <span class="comment"># discovered shortest path</span></span><br><span class="line">                    totaldist = seen[<span class="number">0</span>][w] + seen[<span class="number">1</span>][w]</span><br><span class="line">                    <span class="keyword">if</span> finalpath == [] <span class="keyword">or</span> finaldist &gt; totaldist:</span><br><span class="line">                        finaldist = totaldist</span><br><span class="line">                        revpath = paths[<span class="number">1</span>][w][:]</span><br><span class="line">                        revpath.reverse()</span><br><span class="line">                        finalpath = paths[<span class="number">0</span>][w] + revpath[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment">#raise nx.NetworkXNoPath(f&quot;No path between &#123;source&#125; and &#123;target&#125;.&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">None</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/07/%E9%80%89%E8%B7%AF/" data-id="cl77bm6q4000g2kfy4v2s1lzd" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/06/23/CCSDS/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/06/07/first/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/07/25/SDN_Final/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/24/SDN/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/18/%E7%AE%80%E5%86%99/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/07/17/%E7%BA%BF%E6%80%A7%E4%BA%92%E8%A1%A5%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>